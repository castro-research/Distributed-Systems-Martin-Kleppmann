# Distributed Systems 3.1: Physical time

Olá a todos, bem-vindos à terceira palestra de sistemas distribuídos

hoje vamos nos divertir falando sobre tempo, relógios e ordenação de eventos em um sistema distribuído, então

deixe-me começar com um pequeno quebra-cabeça, algo sobre o qual você pode refletir e que resolverei no final deste vídeo.

Este é um incidente, um incidente real que ocorreu em 2012, no dia 30 de junho, onde administradores de sistemas de várias empresas e serviços diferentes tiveram um dia muito ruim porque, por algum motivo, vários servidores travaram e pararam de responder às solicitações quase ao mesmo tempo, em algum momento no meio da noite.
Então o que pode ter acontecido? Por que os servidores de várias empresas diferentes falharam ao mesmo tempo? Vamos pensar sobre isso e a resposta virá mais tarde.
Então, eu quero falar sobre tempo, e o tempo é muito útil em sistemas distribuídos e em sistemas operacionais. Só para lembrar alguns usos do tempo, por exemplo, em um agendador de sistema operacional, você deseja alternar o contexto após um processo estar em execução por 10 milissegundos. Talvez você tenha que medir esses 10 milissegundos. Se você quiser enviar algum tipo de tempo limite, é claro que você tem que medir esse tempo. Na última aula, falamos sobre detectores de falhas, que novamente dependem da medição se você obteve uma resposta ou não dentro de um determinado período de tempo. Se você quiser tentar enviar mensagens novamente por uma rede, provavelmente você desejará esperar por um determinado tempo.
todos eles exigem medição de tempo, outras coisas que exigem medição de tempo são as medições de desempenho, então há quanto tempo o processo está em execução, quanto tempo de CPU ele está usando, se você deseja criar um perfil de um sistema para melhorar seu desempenho, isso também depende da medição de tempo
em arquivos de log você provavelmente deseja registrar a data e a hora em que um determinado evento aconteceu, então, por exemplo, um determinado usuário fez login em uma determinada data e hora, você deseja registrar isso no log, em bancos de dados você pode querer registrar quando algo acontece, então em que ponto um usuário fez uma compra, por exemplo, em que data e a que horas essa compra ocorreu
um interessante são os dados que são válidos apenas por um certo período de tempo, então em um cache, por exemplo, você pode querer que os dados no cache não vivam para sempre, mas sejam expirados do cache depois de estarem lá por um tempo
Então, darei um exemplo concreto disso. Poderíamos usar DNS, então o sistema DNS para resolver nomes de domínio em endereços IP. Podemos consultar, então podemos fazer algo assim. Vou consultar o site do laboratório de informática aqui e ele me retornará o endereço IP desse site. Se você olhar para esta resposta aqui, poderá ver na segunda coluna esses números, e esses números representam o tempo de vida em segundos desses registros. Isso significa que você tem permissão para armazenar em cache os resultados dessa consulta DNS por um determinado período de tempo, sete mil segundos, o que dá cerca de duas horas ou algo assim, e os resultados podem ser armazenados em cache. Mas depois que esse tempo tiver decorrido, precisamos atualizar a consulta. Precisamos executá-la novamente para obter dados novos, de modo que, se alguém quiser alterar o registro DNS, ele eventualmente se propague para todos os lugares. Agora posso executar isso novamente alguns segundos depois.
veja que agora 7338 caiu para 7293 porque esse número de segundos decorreu enquanto eu estava falando agora, outro exemplo interessante de onde, hum, onde as medições de tempo acontecem é em um site, então digamos que aqui eu tenho o site do laboratório de informática novamente e estou conectado a ele via https, o que significa que ele tem aqui um certificado, um certificado tls que é usado como um mecanismo para verificar se estamos realmente falando com o servidor correto, não com algum servidor falso que está tentando representar este site e se eu visualizar o certificado, bem, novamente, um certificado é válido apenas por um determinado período de tempo, então ele tem uma data de validade aqui, então este certificado expira novamente em 2 de novembro de 2020. Estou gravando este vídeo aqui no final de setembro de 2020, então, no momento em que estou falando aqui, o certificado ainda tem pouco mais de um mês antes de expirar e, portanto, será renovado de tempos em tempos a cada dois meses para que continue atualizado, mas aqui novamente isso requer meu c para que meu computador verifique se o certificado é válido, meu computador precisa saber quais são os dados atuais porque, caso contrário, o computador não será capaz de dizer se estamos dentro do período de validade deste certificado ou não, então esse é outro uso interessante do tempo.
E então, finalmente, usamos medições de tempo para determinar em um sistema distribuído em que ordem certos eventos ocorreram e falarei mais sobre isso posteriormente nesta palestra. Existem dois tipos de relógio que encontramos em sistemas distribuídos e os distinguimos como chamados relógios físicos e lógicos.
Relógios físicos são o tipo de relógio que você conhece pelo uso diário. Eles contam o número de segundos decorridos, informam que horas são e que data é. E é sobre esse tipo de relógio que estamos falando nesta palestra. Relógios lógicos. Abordarei isso na próxima palestra. Agora, apenas um pequeno esclarecimento de terminologia. O termo relógio também é usado em eletrônica digital e você o encontrou lá, onde significa um sinal que produz pulsos de uns e zeros em uma determinada frequência regular. Em sistemas distribuídos, usamos a palavra relógio de uma maneira ligeiramente diferente, então o significado em sistemas distribuídos é que um relógio é algo que você pode solicitar um registro de data e hora, então ele informa qual é a hora atual e a hora atual é representada como um registro de data e hora, que pode ser a data e a hora atuais.
então a maneira que a maioria dos computadores implementa relógios hoje em dia é usando quartzo
cristais de quartzo
então isso é literalmente um pedaço de quartzo, normalmente não um cristal de quartzo natural, mas um cultivado artificialmente, mas ainda é dióxido de silício e é cortado em um certo tamanho e em um certo formato usando lasers e então vibra mecanicamente para que ressoe mecanicamente em uma certa frequência e a frequência na qual ressoa pode ser ajustada cortando pedaços do cristal usando lasers. O quartzo também é um material piezoelétrico, o que significa que se você aplicar um campo elétrico a ele, ele induz uma deformação mecânica no material e também o contrário, se você aplicar uma força a ele, ele cria um campo elétrico e então você pode ter, você pode usar essa interação entre o movimento mecânico e o campo elétrico para criar um oscilador bastante preciso que ressoe em uma frequência bastante precisa e então há um pouco de eletrônica ao redor do cristal de quartzo, mas essencialmente ele produz um sinal com uma certa frequência fixa. Agora, essa frequência é bastante previsível e isso torna os relógios de quartzo bastante precisos, mas certamente não são perfeitos porque sempre haverá certas diferenças de fabricação entre um cristal e outro, eles não oscilarão precisamente na mesma frequência, haverá um pequeno erro, além disso, a frequência de ressonância de um cristal de quartzo depende da temperatura e, portanto, os cristais usados ​​para osciladores de quartzo são ajustados, selecionados e criados de tal forma que são
A frequência deles é bastante estável em torno da temperatura ambiente, em torno de 20 a 25 graus Celsius, mas conforme você se desvia significativamente dessa temperatura, há uma diminuição quadrática na velocidade do clock. Então, se você estiver em uma sala de servidores muito quente, por exemplo, onde você sabe que pode atingir temperaturas significativamente mais altas do que a temperatura ambiente típica, isso pode ter um impacto significativo na frequência com que o clock está funcionando.
então a velocidade do relógio é medida em partes por milhão, geralmente isso é como uma porcentagem, mas em vez de dividir por 100, dividimos por um milhão e então você pode calcular como se tivesse um erro de ppm, isso significaria que o relógio erra em cerca de 32 segundos por ano. Agora, a maioria dos relógios de quartzo terá talvez 20 ppm ou algo assim, ordem de magnitude, claro, dependendo da temperatura. Como regra geral, provavelmente a maioria dos erros de relógio estará abaixo de 50 ppm. Agora, se isso não for preciso para você, não for preciso o suficiente para você, você pode usar um relógio atômico. Os relógios atômicos são muito, muito, muito mais precisos e são baseados em efeitos mecânicos quânticos, então eles realmente usam átomos de césio de um certo isótopo de césio e, se você se lembra de alguma mecânica quântica, os átomos têm níveis de energia discretos. A diferença entre esses níveis de energia corresponde a certas frequências ressonantes do átomo. E há uma transição de energia específica que está em uma frequência bastante amigável para medir, de cerca de nove gigahertz, então você obtém cerca de nove oscilações disso por segundo e é assim que o segundo agora é definido, então a unidade SI de um segundo é definida como sendo exatamente 9 bilhões e 192 milhões de períodos blá blá deste sinal específico gerado a partir desta frequência ressonante específica de átomos de césio
agora isso é incrivelmente preciso, é claro que os relógios não são tão baratos, mas você pode simplesmente comprar um relógio pronto se tiver dinheiro
Não tenho certeza de quanto custaram, mas essas foram as melhores estimativas que consegui obter na internet
E, bem, se você tem um relógio atômico, você pode fazer algumas coisas interessantes com ele, como usar, você pode construir GPS, por exemplo. Então, se você quer um sinal de relógio muito preciso, uma maneira de obter esse relógio é usar GPS.
Então, o mesmo sistema que você usa no seu smartphone para lhe dizer onde você está agora em um mapa funciona com um monte de satélites que orbitam a Terra e cada satélite carrega uma fechadura atômica que transmite seu relógio atual e sua localização atual periodicamente.
E então o receptor GPS recebe os sinais de vários desses satélites, ele calcula a diferença de tempo entre quando o sinal foi enviado pelo satélite e quando o sinal foi recebido pelo seu telefone e a partir da distância no tempo e da velocidade da luz, ele pode calcular a distância real no espaço entre você e o satélite e a partir disso, ele pode descobrir onde você está agora. Há muitos detalhes que contribuem para tornar isso preciso, mas para nossos propósitos, bem, você sabe, tudo o que realmente nos interessa agora é o tempo, não a localização, e você pode usar satélites GPS como uma maneira muito precisa de obter hora e relógios. Agora, isso depende da capacidade de realmente captar o sinal do satélite. Então, se você estiver em um data center, provavelmente há tanta blindagem e interferência eletromagnética que você não consegue captar o sinal, então você tem que colocar uma antena no telhado do data center, mas isso é algo que as pessoas realmente fazem como uma forma de obter relógios precisos.
Então, muito sobre como os relógios realmente funcionam agora, como o tempo é definido? Então você pode ter se deparado com o termo UTC, o Tempo Universal Coordenado Universal, que é o tempo de referência usado para todos os nossos fusos horários que usamos hoje em dia. Como o UTC é realmente definido? Temos que ser precisos sobre isso? Então você provavelmente já se deparou com o termo GMT Greenwich, entretanto, cujo significado infelizmente mudou ao longo do tempo. Seu significado original era tempo baseado em observações astronômicas, então era literalmente quando o sol nasce, quando o sol está no sul? Se você está olhando para o sol do Observatório de Greenwich, então você pode literalmente ir para Greenwich, no sudeste de Londres, visitar o observatório de lá e ver o meridiano em que foi definido que quando o sol está no sul, visto deste lugar específico, então é meio-dia. Agora ele variou. O tempo varia um pouco ao longo do ano, então dessa forma, na verdade, fazemos a média ao longo do ano, mas a ideia ainda é que este é o tempo baseado em observações astronômicas. Agora eu disse apenas relógios atômicos. Eles definem o tempo usando átomos de césio. Então, usando a mecânica quântica, e é assim que o tempo é definido. O tempo atômico internacional é: vamos pegar as travas atômicas. Pegamos algumas centenas de relógios atômicos espalhados pelo mundo. Nós os sincronizamos e contamos exatamente o número de oscilações que temos dessa frequência de ressonância de césio. E isso nos diz quantos segundos se passaram. Essas duas coisas infelizmente não correspondem exatamente. Então, temos duas definições diferentes de tempo, uma baseada na astronomia e a outra baseada na mecânica quântica. E essas duas coisas não correspondem exatamente. Elas são bem próximas, mas especialmente as observações baseadas na astronomia são problemáticas porque a velocidade de rotação não é totalmente constante. Na verdade, a Terra oscila um pouco e às vezes gira um pouco mais rápido e às vezes gira um pouco mais devagar. E isso é afetado por terremotos, marés e todos os tipos de efeitos estranhos e complicados. Então, o resultado é que, bem, queremos usar o tempo atômico porque é muito mais preciso do que esse tempo instável da Terra, mas, ao mesmo tempo, queremos que nosso tempo seja consistente com a forma como a Terra gira em torno de... seu eixo e então o compromisso é UTC. O compromisso é que pegamos o tempo atômico, o tempo atômico internacional, e aplicamos algumas correções a ele com base na astronomia, e isso nos dará um tempo que é baseado na mecânica quântica, mas ainda consistente com observações astronômicas. É um pouco complicado, mas é com isso que acabamos. Então é assim que UTC é definido e fusos horários e como todos os horários de verão e inverno, todos eles são definidos como deslocamentos para UTC agora. Então, se você estiver na costa leste dos EUA, por exemplo, você estará em UTC mais cinco, por exemplo. Agora, como essa correção do tempo atômico para UTC se parece? A resposta é que a correção assume a forma de segundos bissextos. Então, todos vocês já ouviram falar de anos bissextos antes. Anos bissextos são uma coisa muito familiar. Este é um conceito diferente, mas é igualmente estranho. É ainda mais estranho, na verdade.

e então um segundo bissexto é um segundo extra que pode ser inserido ou removido em uma determinada data e então todo ano há normalmente duas datas em que um segundo bissexto pode não acontecer e que é 30 de junho e 31 de dezembro em princípio eu acho que pode acontecer no final de cada mês mas esses são os dois meses que são normalmente usados ​​e nesse ponto uh alguns meses antes do segundo bissexto pode ou não acontecer os astrônomos decidem ok quão rápido a Terra tem girado nos últimos meses ok precisamos inserir um segundo ou não para manter o UTC bastante consistente com a rotação da Terra e então dependendo do que os astrônomos decidirem então o relógio pode ou não ter um segundo extra e então isso significa na verdade que então se houver um segundo subtraído então não há 23 59 59 segundos o relógio vai 58 e então imediatamente salta para zero após um segundo então o 59 segundo é simplesmente pulado ou poderíamos ter um segundo regular ou podemos ter um segundo adicional no qual o relógio vai de 59 59 a 60 e depois a zero após dois segundos, então inserimos um segundo extra em 23 59 e 60. Agora, isso parece complicado e é, e infelizmente os computadores não são muito bons em lidar com isso, então há duas representações típicas de tempo que são mais comumente usadas em programas de computador. Primeiro, o tempo Unix, que é simplesmente um número, um inteiro que conta o número de segundos desde um ponto arbitrário no tempo, o primeiro de janeiro de 1970 foi escolhido arbitrariamente, pois isso é chamado de época Unix e contamos o número de segundos, exceto que o tempo Unix é definido como não contando os segundos bissextos, ou melhor, o padrão simplesmente não diz nada sobre segundos bissextos, está simplesmente implícito que, bem, eu não sei quem se importa com segundos bissextos, tanto faz.
mas é definido em termos de utc, então não é realmente utc, é uma espécie de horário atômico internacional, na verdade, em vez de utc, mas todo mundo diz que é utc, então o que é isso? Além disso, há esse outro formato de representação de datas e horas que é iso8601, que é baseado em ano, mês, dia, hora, minuto, segundos. Isso é conveniente porque é fácil para os humanos lerem, mas agora significa que temos que converter entre essas duas representações e, portanto, a conversão primeiro precisa que você conheça o calendário, então, ok, sabemos como funciona o calendário gregoriano. Temos 365 dias em um ano, exceto que adicionamos um 29 de fevereiro extra em anos bissextos se o ano for divisível por quatro, mas não se o ano for divisível por 100, mas se o ano for divisível por 400, então adicionamos um dia bissexto, afinal, ok, então esses são os nossos anos bissextos, mas, na verdade, para converter corretamente esses formatos, também devemos levar em consideração os segundos bissextos, porque eles também determinam o número, o número de segundos que têm decorrido desde 1º de janeiro de 1917 porque eles foram, eu acho, mais de 20 segundos intercalados inseridos desde aquele ponto. Bem, como você acha que o software lida com esses problemas de segundos intercalados?
você adivinhou, o software ignora, o software faz la la la la la, não há segundos intercalados, eu não me importo e só espero que o problema desapareça, infelizmente o problema não desaparece e, claro, para alguns aplicativos, isso realmente não importa porque você sabe, um segundo aqui ou ali, para muitos aplicativos realmente não faz muita diferença, você sabe se quer ter em sua atualização de status do Facebook a que horas você postou a atualização de status do Facebook, se estiver errado por um segundo, ninguém vai se importar.
mas em sistemas operacionais e sistemas distribuídos, muitas vezes confiamos em medições de tempo bastante precisas com precisão de subsegundos e, nesse caso, na verdade, a diferença de um segundo pode ser bastante significativa e isso significa que realmente temos que nos preocupar com esses segundos intercalados, o que nos leva à solução do pequeno quebra-cabeça que apresentei no início desta palestra, que é o que aconteceu no dia 30 de junho de 2012 para todos esses sistemas caírem ao mesmo tempo. Bem, a resposta foi que um segundo intercalar aconteceu e não havia um segundo intercalar por alguns anos antes disso e então, durante esses anos, é claro, o kernel do Linux e todos os outros softwares foram atualizados e o bug foi introduzido e, como resultado, houve na verdade uma condição de bloqueio ativo, quando o segundo intercalar aconteceu, o sistema entrou em bloqueio ativo e então estava apenas girando 100 CPUs e não realizando nenhum trabalho útil e mesmo reinicializar os computadores não ajudou. O que os administradores descobriram então foi que você realmente tinha que redefinir o relógio do sistema e isso de alguma forma limpou o mau estado no kernel do Linux e nos permitiu consertar aqueles computadores novamente, mas você pode imaginar que esse foi um dia realmente ruim para os administradores desses sistemas que reinicializaram os sistemas e eles ainda não funcionaram. Agora, uma solução é mais amplamente usada, que tenta contornar esse problema de que a maioria dos softwares não sabe como lidar com os segundos intercalados corretamente e a solução é chamada de mancha de segundo intercalado.
borrar, o que é diferente de se formos inserir um segundo intercalar em vez de inseri-lo em um momento específico, que tal simplesmente espalharmos esse segundo intercalar ao longo de um dia inteiro, então digamos, por exemplo, 12 horas antes e 12 horas depois que o segundo intercalar deve ser introduzido, nós apenas desaceleramos os relógios um pouco o suficiente para que, no total, um segundo adicional tenha decorrido ao longo desse período, mas sem essa descontinuidade de tempo em que adicionamos aquele segundo extra que confunde todo o software e isso é

é uma espécie de hack, na verdade, não é uma solução muito elegante, mas pode ser pragmaticamente a melhor que podemos inventar, dado o problema de que há tantos softwares por aí que não sabem como lidar com segundos intercalares e, realisticamente, não vamos conseguir atualizar todos esses softwares, então provavelmente essa abordagem de difamação é a melhor que temos, mas de qualquer forma, essa é a história por trás dos segundos intercalares e por que eles realmente têm um impacto bastante significativo em nossos sistemas.


# Sistemas Distribuídos 3.2: Sincronização de relógio

A seguir, vamos falar sobre sincronização de relógio, então estabelecemos que cada computador contém um relógio de quartzo, não um relógio atômico, porque relógios atômicos são muito caros e muito volumosos, então o que precisamos fazer é nos contentar com esses relógios de quartzo menos precisos e temos que, de alguma forma, tentar fazer com que os relógios sejam razoavelmente precisos, no entanto, esses relógios de quartzo irão se desviar um pouco porque sua taxa não corresponde exatamente ao que a taxa de tique-taque do relógio correto deveria ser e acabamos com distorção do relógio, então a distorção do relógio é se olharmos para dois relógios diferentes no mesmo instante no tempo e compararmos os carimbos de tempo desses relógios, os relógios usam a diferença entre os dois e o que queremos fazer com a sincronização do relógio é minimizar a distorção o máximo possível agora nos tipos de redes que temos em redes assíncronas ou parcialmente síncronas, não é possível reduzir a distorção do relógio a zero, o melhor que podemos fazer é reduzi-la o máximo que pudermos, mas sempre haverá um pouco de tolerância a erros restante agora, a maneira como normalmente fazemos a sincronização do relógio na prática é usando um protocolo chamado NTP, o protocolo de tempo de rede, há também outro protocolo chamado PTP, mas não falaremos sobre isso neste curso. A maneira como o NTP funciona é que há um servidor e presumimos que o servidor tem alguma fonte de relógio precisa, como um relógio atômico ou receptor GPS, e os clientes podem consultar o servidor e perguntar a hora atual do servidor e, em seguida, o cliente ajustará sua própria hora com base na hora que recebeu do servidor. Portanto, o NTP é amplamente implantado. Quase todos os sistemas operacionais usados ​​hoje em dia têm o NTP integrado. Por exemplo, no macOS, a caixa de diálogo de configurações se parece com esta aqui. Você pode escolher o servidor NTP aqui ou digitar o seu próprio. Neste caso, tenho time.euro.apple.com como meu servidor de hora, mas a maioria dos outros sistemas operacionais terá uma caixa de diálogo muito semelhante, onde você também pode ajustar e escolher seu servidor NTP, se quiser. Agora, a maneira como o NTP funciona é que os servidores são organizados no que são chamados de estratos.


então o estrato 1 são apenas as fontes de tempo precisas, ou seja, relógios atômicos ou receptores GPS. O estrato 1 é um servidor que está conectado diretamente a uma fonte de tempo do estrato 0. O estrato 2 é um servidor que não está conectado diretamente a uma fonte de tempo precisa, mas que obtém seu tempo de um servidor do estrato 1 e do estrato. O servidor do estrato 3 obtém seu relógio de um servidor do estrato 2 e assim por diante.


todo o conjunto de técnicas e truques estatísticos que são usados ​​para tentar melhorar a qualidade de nossas estimativas de tempo, então uma coisa que o NTP faz é, por exemplo, consultar vários servidores se eles estão disponíveis, porque pode ser que um desses servidores esteja mal configurado ou tenha uma falha ou algo assim e, portanto, esteja relatando um tempo extremamente impreciso e assim


Se você estiver consultando três ou cinco servidores, poderá dizer se há um dos servidores que é um outlier real e os outros servidores estão todos muito próximos, nesse caso, o NTP pode excluir esse outlier e apenas manter os pontos de dados dos servidores que parecem ser confiáveis. Outra técnica usada é consultar um servidor não apenas uma, mas várias vezes ao longo de vários minutos, o que garantirá que pelo menos quaisquer variações aleatórias no atraso da rede possam ser filtradas. Agora, se houver variações sistemáticas no atraso da rede, ter várias amostras não ajudará, mas pelo menos várias amostras reduzirão o erro aleatório. E com o NTP, se você tiver uma conexão de rede de boa qualidade, é possível sincronizar seu relógio com o servidor em alguns milissegundos. Distorção. Se você estiver em uma conexão de rede de baixa qualidade por meio de algum tipo de wi-fi ocupado por meio de uma conexão de internet muito carregada, a precisão pode ser muito pior do que isso. Portanto, você sempre deve ter cuidado ao assumir relógios sincronizados. Agora, vamos dar uma olhada em como o NTP estima a distorção do relógio. entre o cliente e o servidor funciona enviando uma mensagem


através de uma rede novamente como de costume, então temos uma mensagem de solicitação que poderia ser enviada do cliente para o servidor e como o cliente está enviando esta mensagem, ele registra o relógio de acordo com o registro de data e hora do cliente, o registro de data e hora t1, que é o registro de data e hora em que o cliente enviou esta mensagem e ele copia esse registro de data e hora t1 na mensagem de solicitação. O servidor NTP, quando recebe essa mensagem, também registrará a hora de acordo com o próprio relógio do servidor em que recebeu esse registro de data e hora e chamaremos isso de t2, em que ele recebeu essa mensagem, chamaremos isso de


t2 agora o servidor pode levar um pouco de tempo para processar a mensagem, mas eventualmente o servidor responderá e t3 é o registro de data e hora de acordo com o relógio de serviço em que a resposta foi enviada


então agora a resposta irá conter todos os três registros de data e hora até agora


Então t1 é simplesmente copiado da solicitação para a resposta. O servidor não faz nada com t1. T2 e T3 vêm do relógio de superfície como o tempo de chegada e o tempo de resposta, respectivamente. E, finalmente, quando a resposta é recebida pelo cliente, o cliente registra novamente o registro de data e hora de acordo com o relógio do cliente no momento em que a resposta foi recebida. Então, temos agora quatro registros de data e hora e, a partir desses registros de data e hora, vamos tentar descobrir qual é a distorção entre os dois relógios. Então, primeiro, podemos descobrir quanto tempo a mensagem gasta viajando pela rede. Vamos chamar isso de delta de atraso total da rede. Esse tempo tem que ser t4 menos t1, então esse é o tempo total gasto do ponto de vista do cliente, do momento em que enviou a solicitação até o momento em que recebeu uma resposta, menos o tempo que a mensagem foi gasta processando no servidor. Então, menos t3 menos dois, que é o tempo de processamento no servidor. O tempo restante tem que ser o tempo total gasto na rede pela resposta e pela solicitação. juntos agora o que não sabemos é a repartição desses dois quanto tempo a solicitação passou na rede e quanto tempo a resposta passou na rede passam em uma rede se você quiser calcular essa latência de rede unidirecional você precisa de relógios sincronizados e o ponto principal deste exercício aqui é que não temos um relógio sincronizado estamos tentando construir um relógio sincronizado então não temos uma maneira de medir essa latência de rede unidirecional nós só podemos medir a soma das duas latências de rede juntas mas o que podemos fazer é apenas fazer uma suposição de que a latência da rede é simétrica em ambas as direções então vamos assumir que a latência da solicitação é a mesma que a latência da resposta e se isso for verdade então a latência da resposta será delta sobre 2 porque será apenas metade do atraso total então isso significa que agora podemos estimar o timestamp que o servidor deve ter no momento em que a resposta é recebida pelo cliente então do ponto de vista do cliente é tempo t4 mas sabemos que o servidor enviou sua resposta em t3 e vamos estimar que a resposta gastou delta sobre 2 viajando pela rede e então vamos estimar que no momento em que o cliente recebe a resposta o relógio no servidor diz t3 mais delta sobre 2 essa é a nossa estimativa do relógio do servidor agora que temos uma estimativa do relógio de superfície podemos estimar o desvio do relógio porque podemos simplesmente pegar nossas estimativas do relógio de serviço menos t4 que é o relógio do cliente e isso nos dará a diferença instantânea de tempo entre os dois relógios naquele momento e então se você substituir em delta e simplificar a expressão você obtém esta expressão aqui que é a nossa melhor estimativa que podemos fazer do que é o desvio do relógio agora que temos que inclinar entre os dois relógios o cliente pode corrigir seu próprio relógio e tenta sincronizá-lo com o servidor e o que o cliente faz nessa situação agora depende de quão grande é o desvio do relógio então primeiro vamos olhar para o caso em que o desvio do relógio é bastante pequeno então digamos que theta é menor que 125 milissegundos neste caso o que o O cliente vai fazer é acelerar ou desacelerar um pouco seu relógio conforme necessário para alinhá-lo com o servidor e, portanto, ele vai mudar sua taxa de relógio no máximo em 500 ppm, no máximo em meio milissegundo por segundo de ajuste e, portanto, ao longo de alguns minutos, isso significa que, com sorte, o relógio do cliente e o relógio do servidor irão se aproximar e convergir para o mesmo estado e isso é chamado de "girar o relógio", que é o termo que o NTP usa para isso. Se a distorção for muito grande entre o cliente e o servidor, então o NTP vai acelerar o relógio, o que significa que ele simplesmente ajustará o relógio à força, então, mesmo que isso signifique mover o relógio para trás ou para frente, ele vai pular direto para o registro de data e hora estimado a partir do relógio do servidor e, a partir daí, vai tentar fazer tudo sem problemas, mas há essa descontinuidade inicial de tempo em que o cliente acelera seu relógio e, finalmente, pode acontecer que o NTP decida que a distorção entre o cliente e o servidor é tão grande que o NTP se recusa a ajustar o relógio, ele apenas diz não, não vou fazer nada, vou presumir que algo deu muito errado, não sei se o relógio do cliente está muito errado ou o relógio do servidor está muito errado, mas isso é tão ruim que não vou fazer nada aqui, vai deixar o ajuste para o operador humano resolver, então isso significa que agora, se você tiver um software que depende da sincronização dos relógios, você precisa ter muito cuidado para medir a distorção do relógio entre os relógios e garantir que ela não fique muito grande, porque pode acontecer de um cliente NTP acabar nesse estado de pânico e simplesmente se recusar a sincronizar seu servidor para sincronizar seu relógio com o servidor e, então, você tem um cliente NTP cujo relógio está muito errado, pode estar meia hora ou mais errado em comparação com o servidor e o NTP não vai corrigir isso, então você precisa ter muito cuidado se tiver um software que assume relógios sincronizados. Este é um exemplo de rotação em ação, então você pode ver aqui o A linha vermelha aqui é a inclinação, o deslocamento entre os dois relógios e começa em cerca de 10 milissegundos de deslocamento e então a correção é aplicada para que acabe sendo em torno de zero, inclinação do relógio e a linha azul é a taxa de tique na qual o relógio do cliente está funcionando e então o cliente aqui aplicou uma inclinação de até cerca de menos 45 ppm, o que significa que o cristal de quartzo no cliente deve ter sido um pouco rápido, ele estava funcionando um pouco rápido em cerca de 45 ppm e ao desacelerar o quartzo em 45 ppm agora o cliente NTP trouxe a taxa de tique do cliente aproximadamente em linha com o servidor, então agora ambos os relógios estão avançando aproximadamente na mesma taxa e não se afastando mais, então isso é muito bom, mas a consequência do NTP é que você tem que ser muito cuidadoso ao escrever certos pedaços de código, então este é um pedaço de código que provavelmente ocorrerá em todos os tipos de softwares diferentes onde você tem alguma função que faz algo aqui e você quer medir quanto tempo essa função leva para ser executada e assim em Para medir esse tempo, você simplesmente pega um registro de data e hora do relógio antes de iniciar a função e pega outro registro de data e hora depois de terminar a função e então calcula a diferença entre os dois. Este é um exemplo aqui em Java, mas isso poderia muito bem ser em qualquer outra linguagem de programação. Não é específico para Java. Agora, o que poderia acontecer é que o NTP decide adiantar o relógio enquanto você está no meio da execução desta função "faça algo" e o adiantamento do relógio significa que agora o registro de data e hora retornado pelo tempo atual em milésimos de segundo após o "faça algo" será de alguma forma muito diferente do que era antes, então pode ser que o horário fosse o horário em que o relógio foi movido para trás, caso em que essa diferença nos registros de data e hora pode acabar sendo negativa e quem sabe o que seu software fará se medir uma quantidade negativa de tempo decorrido. As coisas podem travar ou dar muito errado de várias maneiras interessantes. Também pode ser que esse número acabe sendo muito grande porque se o cliente NTP adiantar o relógio nesse caso, agora ele vai ter... no tempo sendo muito maior do que um carimbo de tempo muito maior do que deveria ser e, portanto, a diferença será maior do que deveria ser, então se você quiser fazer esse tipo de medição de tempo, não é bom confiar em um relógio como o tempo atual em milissegundos, em vez disso, o que você deve fazer é usar uma API diferente, então o Java fornece essa outra função aqui chamada system.nanotime e o nanotime é projetado para esse tipo de coisa, então há a diferença superficial: o tempo atual em milissegundos usa milissegundos, o nanotime usa nanossegundos, essa é apenas a diferença superficial. A diferença real é que o nanotime é o que chamamos de relógio monotônico e o relógio monotônico é aquele em que o passo NTP não o afetará, então este relógio não vai pular repentinamente para frente ou para trás como o nome tamanho do nome como o nome diz, relógio monotônico significa que ele se move para frente a uma taxa mais ou menos constante, o giro ainda o afetará porque isso melhora a precisão do relógio, mas ele não vai pular repentinamente com uma descontinuidade e, portanto, usar o nanotime aqui para medir o tempo decorrido é a maneira correta de fazer isso, então isso A diferença entre relógios monotônicos e relógios de hora do dia é muito importante, então o relógio de hora do dia é, por exemplo, o milissegundo de hora atual do Java, que fornece o tempo decorrido desde um ponto de referência fixo. No caso de carimbos de data/hora Unix, é a data de época de primeiro de janeiro de 1970, enquanto um relógio monotônico, o valor que você obtém dele é algum tempo arbitrário desde que, por exemplo, este computador em particular inicializou, então isso significa que o carimbo de data/hora por si só não significa nada. Você não pode enviar o carimbo de data/hora por uma rede para outro computador e compará-los porque dois computadores diferentes inicializaram em momentos diferentes e, portanto, seus carimbos de data/hora monotônicos simplesmente não são comparáveis, mas você pode usar o relógio monotônico para medições de tempo porque se você calcular a diferença entre dois carimbos de data/hora de um relógio monotônico, o tempo terá avançado a uma taxa quase constante entre esses dois carimbos de data/hora e, portanto, essa é uma medida significativa do tempo decorrido, enquanto se você fizer esse tipo de diferença com relógios de hora do dia, será afetado por um salto devido a NTP você também é afetado por segundos intercalados potencialmente, sobre os quais falamos antes, então eles são muito ruins para medir o tempo decorrido, mas, por outro lado, os carimbos de data/hora do dia você pode comparar em diferentes computadores se você se lembrar do exemplo anterior que eu tinha do certificado TLS que era válido até uma certa data se meu computador quiser verificar se esse certificado ainda é válido, bem, ele tem que ter a data atual precisa, caso contrário, não será capaz de comparar o carimbo de data/hora no certificado com o carimbo de data/hora atual naquele computador, então, neste caso, temos que usar um relógio de hora do dia e temos que sincronizar esses relógios em várias máquinas porque, caso contrário, não teremos carimbos de data/hora precisos, então, como eu disse, muitas linguagens de programação e sistemas operacionais fornecem APIs para isso, uh, no Linux, por exemplo, há a chamada de tempo do relógio e você pode passar um argumento para ele, digamos, que diz se você quer o relógio de tempo real, que é o relógio da hora do dia, ou se você quer o relógio monotônico, mas em outras linguagens haverá APIs semelhantes para isso, você terá que verificar a documentação da API, mas é importante ter em mente essa distinção se você precisa medir tempos, não se trata apenas da resolução dos relógios, mas a distinção entre um relógio monótono e não monótono é muito importante


# Sistemas Distribuídos 3.3: Causalidade (Causality) e acontecimentos anteriores (happens-before)

na última parte desta palestra, veremos a ordem relativa de diferentes mensagens e diferentes eventos que podem acontecer em um sistema distribuído e como podemos usar o tempo neste contexto


Então, vamos começar com um exemplo novamente, vamos começar com um exemplo de um tópico de discussão na internet e você sabe, uma daquelas discussões intelectuais típicas onde


um usuário diz "a lua é feita de queijo" e outro usuário responde dizendo "não, você está errado"


Então, vamos modelar esse tipo de tópico de discussão aqui, digamos que temos o usuário 1, desculpe, o usuário a aqui, que diz que a lua é feita de queijo, envia a mensagem m1 para os usuários b e c, e vamos apenas assumir nosso modelo de sistema usual de, digamos, links de rede confiáveis, mas as mensagens podem ser atrasadas ou podem ser reordenadas como de costume, e então pode acontecer que o usuário b receba a mensagem m1 bem rápido e o usuário c receba essa mensagem um pouco mais tarde, só porque ela foi atrasada um pouco na rede, tudo bem.


agora o usuário b responde à mensagem um, o usuário b recebe m1 e diz não, a lua não é feita de queijo e envia isso como mensagem m2 de volta para o usuário a e também para o usuário c. agora o que pode acontecer é o que você vê neste diagrama aqui é que o usuário c na verdade recebe m2 antes de receber m1


e isso é meio confuso porque se você imaginar que o usuário c está olhando para este tópico, ele primeiro vê "ah, não, não é" e então "a lua é feita de queijo", então, mesmo que "ah, não, não é" realmente não deveria ser uma resposta para "a lua é feita de queijo", acabamos reordenando-os e temos a resposta antes da coisa à qual ele está respondendo.


isso é muito confuso, então vamos pensar em como podemos formalizar esse problema e como podemos criar algoritmos que o resolvam.


Então, isso é baseado nessa ideia de que uma coisa aconteceu antes da outra. Acho que podemos concordar que m1 aconteceu antes de m2, porque se m2 é uma resposta a m1, então m1 deve ter acontecido primeiro. Há algum tipo de tempo lógico no sistema aqui, mas vamos ver o que acontece se anexarmos registros de data e hora a cada mensagem. Então, digamos que quando o usuário a envia a mensagem m1, o usuário a também usa o relógio local de a para gerar um registro de data e hora t1 e anexa o registro de data e hora t1 à mensagem m1. E também quando o usuário b recebe m1 e envia m2, o usuário b obtém um registro de data e hora t2 do relógio local de b e anexa esse registro de data e hora à mensagem m2 que é enviada aos outros dois nós.


e agora vamos assumir que estes são, claro, relógios físicos de hora do dia, vamos assumir que os relógios estão sincronizados usando algo como mtp, mas ainda pode acontecer mesmo se sincronizados, se os relógios estiverem sincronizados, pode acontecer que o carimbo de data/hora t2 seja na verdade menor que o carimbo de data/hora t1, isso pode acontecer porque a distorção do relógio entre dois nós em um sistema pode ser maior que o atraso de rede unidirecional entre esses dois nós e mesmo com a sincronização ntp, não podemos descartar a possibilidade de que a distorção do relógio seja maior que o atraso de rede unidirecional, a latência da rede não unidirecional e, portanto, neste caso, aqui m1 está experimentando algum tipo de latência, mas essa latência é menor que a distorção do relógio entre os usuários a e b e, nesse caso, se o relógio do usuário b estiver um pouco atrasado e o relógio do usuário a estiver um pouco mais rápido, você pode acabar com t2 sendo menor que t1 e, portanto, todo o nosso objetivo deste exercício era garantir que as mensagens fossem colocadas na ordem correta de acordo com o tempo, mas mesmo usando o tempo aqui, temos na verdade, não foi possível colocar as mensagens na ordem correta porque a ordem do carimbo de data/hora é inconsistente com nossa compreensão de qual mensagem é uma resposta a qual outra mensagem, então como resolvemos esse problema


O que fazemos em sistemas distribuídos é usar algo chamado de relação "acontece antes" e, portanto, este é um modelo matemático de atividade que aconteceu no sistema distribuído e, portanto, quando falamos sobre atividade em um sistema distribuído, primeiro precisamos definir quais são as coisas que acontecem. Então, diremos que as coisas que acontecem são eventos. Um evento pode ser apenas um processo, desculpe, um nó no sistema realizando uma etapa de execução local. Um nó fazendo algo que pode ser um evento. Ou um evento pode ser uma mensagem que um nó envia para outro.


Então, o envio da mensagem é um evento e o recebimento da mensagem é outro evento. Se a mensagem chega, o recebimento seria outro evento. Agora podemos definir uma relação que é um par, um conjunto de pares de eventos que descreve como esses eventos se relacionam entre si. E isso acontece antes. A relação é escrita como uma seta b. Se a aconteceu antes de b, e dizemos que a aconteceu antes de b se pelo menos uma das três coisas for verdadeira.


então a primeira coisa é que os dois eventos a e b aconteceram no mesmo nó e a ocorreu antes de b na ordem de execução local desse nó, o que significa que estamos assumindo que cada nó é um único processo de thread que está apenas fazendo uma coisa após a outra, então não há ambiguidade sobre a ordem em que as coisas aconteceram em um único nó. Se houver uma única thread, as coisas só acontecem uma após a outra e podemos definir exatamente qual coisa aconteceu primeiro e qual acontece em segundo lugar, então vamos assumir que para cada nó há uma ordem total estrita de todos os eventos que aconteceram naquele nó específico. Se quiséssemos oferecer suporte a processos multithread, poderíamos ter cada thread sendo um nó separado para os propósitos deste modelo aqui.


Então, podemos apenas assumir threads únicos por enquanto e então vamos dizer que a aconteceu antes de b se eles aconteceram no mesmo nó e foram executados a foi executado antes de b isso faz sentido


em segundo lugar, diremos que a aconteceu antes de b se a é o evento em que uma determinada mensagem m foi enviada e b é o evento em que essa mesma mensagem foi recebida


Portanto, para tornar isso inequívoco, temos que assumir que as mensagens são únicas, porque, caso contrário, você poderia ter dois eventos diferentes para o envio da mesma mensagem, o que, é claro, poderia acontecer em um sistema real, mas torna a coisa difícil de modelar matematicamente.


Então, para simplificar, aqui apenas assumimos que cada mensagem enviada é única e se quiséssemos realmente tornar as mensagens únicas na prática, poderíamos anexar algum tipo de número de sequência e o identificador do nó que detectou ou enviou uma mensagem, por exemplo, poderíamos anexá-lo a cada mensagem ou poderíamos escolher um longo número aleatório para cada mensagem e isso seria suficiente para tornar cada mensagem única.


e então isso acontece novamente antes que o relacionamento faça sentido porque uma mensagem só pode ser recebida depois de ter sido enviada e, portanto, faz sentido que o envio dessa mensagem específica aconteça antes do recebimento dessa mensagem, ok?


então essas são as duas primeiras cláusulas de acontece antes da terceira é simplesmente se pudermos encontrar algum evento c tal que a aconteceu antes de c e c aconteceu antes de b então também deve ser o caso de que a aconteceu antes de b


então isso é simplesmente pegar o fechamento transitivo dos dois primeiros pontos e estender tudo para o que é chamado de ordem parcial


Então, uma ordem parcial se comporta um pouco como uma relação de menor que entre duas coisas, então ela permite que você compare duas coisas e diga qual aconteceu primeiro, mas pode haver algumas coisas que são incomparáveis ​​de acordo com essa ordem.


onde simplesmente não é o caso de a ter acontecido antes de b ou b ter acontecido antes de a, os dois são simplesmente não relacionados
não é o caso de que um aconteceu antes do outro e nesse caso dizemos que a e b são concorrentes e escrevemos com esta pequena barra dupla este sinal de paralelo aqui


Então isso é interessante aqui agora, para quaisquer dois eventos a e b, acontece que há apenas três possibilidades: a aconteceu antes de b ou b aconteceu antes de a ou os dois são concorrentes e um dos exercícios nas notas pede para você realmente provar o fato de que essas são exatamente as três possibilidades que podem acontecer


Então, vamos dar uma olhada em um exemplo se isso acontece antes do relacionamento, hum, então aqui temos eventos representados como essas pequenas manchas pretas e mensagens enviadas pela rede com essas setas, como de costume, e temos três nós aqui, então vamos construir o que acontece antes do relacionamento a partir das cláusulas individuais e assim


em primeiro lugar, devido à ordem dos eventos que acontecem em um nó específico, bem, aqui o nó a executou a antes de b, portanto, a aconteceu antes de b, o nó b executou c antes de d, portanto, c aconteceu antes de d e o nó c executou e antes de f, portanto, e aconteceu antes de f, ok?


até aqui tudo claro


Em segundo lugar, agora, devido às mensagens enviadas e recebidas, o envio de uma mensagem acontece antes do recebimento dessa mensagem, portanto, b acontece antes de c porque essa é a mensagem m1 viajando pela rede e também d acontece antes de f porque essa é a mensagem de mensagem para viajando pela rede, então agora temos todos esses relacionamentos entre alguns dos eventos. Agora, estendemos tudo isso com o fechamento transitivo e, portanto, devido ao fechamento transitivo, por exemplo, a aconteceu antes de c e a aconteceu antes de d. Basicamente, o que você pode imaginar aqui é que podemos seguir um caminho através deste gráfico. Você pode imaginar qualquer caminho que se move para frente no tempo em um nó ou que se move do envio de uma mensagem para o recebimento dessa mensagem e, em seguida, se move através de outros nós. E você pode seguir qualquer caminho através deste gráfico, contanto que esteja sempre avançando no tempo, então você obterá de qualquer a que aconteceu antes de qualquer outro evento e


Então, aqui, por exemplo, você pode ir de a até f. A aconteceu antes de f porque você pode ir de a para f percorrendo esses dois. Um envia mensagens. Um, mas, por exemplo, você não pode ir de a para e porque ir de a para e exigiria voltar na ordem dos nós de c e isso não seria permitido. Isso significa que, por exemplo, a e e são concorrentes, então a não aconteceu antes de e. E não aconteceu antes de a. Os dois são simplesmente concorrentes, o que significa que são independentes. Um evento não sabia sobre o outro quando aconteceu. Concorrente não significa literalmente simultâneo.


Isso não significa que aconteceu literalmente no mesmo instante de tempo, significa apenas que os dois eventos não sabiam um do outro quando ocorreram e, portanto, a é concorrente com e b é concorrente todos a b c e d são todos concorrentes para e, mas e e f não são concorrentes, é claro, por causa da ordem de uh on on c on user c


Então, isso acontece antes da relação e isso acontece antes da relação está intimamente ligado ao conceito de causalidade em sistemas distribuídos, em particular se a aconteceu antes de b, então pode ser o caso de a ter causado b ou a ter influenciado b de alguma forma, então há algum fluxo de informações que aconteceu de a para b, enquanto se os eventos a e b são simultâneos, sabemos que a não pode ter causado b e b não pode ter causado a, não há relação causal entre os dois, então esse conceito de causalidade é na verdade retirado da física, onde normalmente as pessoas raciocinam sobre eventos que acontecem muito distantes no espaço e a distância e o tempo que a velocidade da luz leva para viajar entre essas coisas, então se você tem dois eventos acontecendo em planetas diferentes, digamos, ou mesmo em galáxias diferentes, e eles estão muito distantes no espaço, mas você pode ter esses eventos acontecendo mais ou menos na mesma época, eles não precisam ser exatamente ao mesmo tempo, mas estão acontecendo bem próximos no tempo, mas bem distantes no espaço, então podemos desenhar este diagrama espaço-tempo aqui, então podemos desenhar este diagrama onde imagine que você envia um feixe de luz do evento a no momento em que o evento a ocorre e você o envia em todas as direções e então, conforme o tempo passa aqui para baixo e o espaço é da esquerda para a direita, então, desta vez, desculpe, esta luz se espalha pelo espaço na velocidade da luz e qualquer evento que aconteça dentro deste cone aqui com ele, isso é chamado de cone de luz, esse evento pode de alguma forma depender de a, mas você pode ver que b aqui está bem fora do cone de luz de a e também uh a está fora do cone de luz de b, então a informação de uh de b no momento em que b ocorreu não poderia ter chegado a a no momento em que a aconteceu e, da mesma forma, a informação quando a aconteceu não poderia ter chegado a b no momento em que b aconteceu simplesmente porque isso exigiria que a informação viajasse mais rápido do que a velocidade da luz e, até onde sabemos em nosso universo, não é possível que a informação viaje mais rápido do que a velocidade da luz, então este evento c aqui, por exemplo, que poderia ser influenciado por a ou b, um, mas b e a não podem influenciar um ao outro e então este é este conceito da física que está intimamente relacionado ao que temos em sistemas distribuídos, que normalmente falam sobre mensagens fluindo por uma rede. em vez da luz viajando pelo universo, mas essencialmente é a mesma ideia, é raciocinar sobre quais eventos poderiam ter afetado uns aos outros


e uma vez que temos essa uh essa causalidade potencial e isso acontece antes do relacionamento, agora podemos ordenar os eventos e então lembre-se em nosso caso de primeiro a lua é feita de queijo e então a resposta a ela, oh não, não é o que queremos é que a lua é feita de queijo venha primeiro nesta ordem do tópico de conversa e então a resposta venha em segundo nessa ordem e aqui porque temos uma relação causal entre m1 que é a lua é feita de ts e m2 que é a resposta a m1 então há uma relação causal entre os dois e então, portanto, a aconteceu antes de b a mensagem um aconteceu antes da mensagem dois o que queremos é que qualquer ordem em que coloquemos as mensagens seja consistente com isso então sempre que a aconteceu antes de b então a ocorre antes de b nessa ordem causal isso é isso é chamado de ordem causal que é uma maneira de colocar os eventos no sistema em uma ordem de tal forma que eles sejam consistentes com a causalidade isto é se uma coisa aconteceu antes de outra coisa então eles aparecem na ordem correta mas se duas coisas são simultâneas então eles podem aparecer em qualquer ordem porque você sabe que um poderia ter acontecido antes do outro não há como dizer qual aconteceu primeiro


Então, nesse caso, eles poderiam ser ordenados arbitrariamente, então este é um conceito muito útil e vamos usá-lo na próxima aula quando se trata de desenvolver essa ideia do relacionamento "acontece antes" e criar alguns algoritmos distribuídos reais que implementam isso. A última coisa que vou apenas apontar é


é muito fácil confundir a palavra causal com a palavra casual porque apenas duas letras são varridas, eu continuo tendo que verificar novamente eu mesmo também, então apenas isso como um pequeno detalhe para ficar atento se você está escrevendo sobre sistemas distribuídos, você provavelmente quer dizer causal, não casual, então até a próxima.

