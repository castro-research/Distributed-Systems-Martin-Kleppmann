# Distributed Systems 3.1: Physical time

hello everyone welcome to the third lecture of distributed systems 

today we're going to have fun talking about time and clocks and ordering of events in a distributed system so 

let me start with a little puzzle something that you can ponder about and i will resolve this towards the end of this video.

this is an incident a real incident that occurred in 2012 on the 30th of june where system administrators at a whole bunch of different companies and services had a really bad day because for some reason a whole lot of servers all locked up and stopped responding to requests all around the same time, Sometime in the middle of the night.
 
 so what might have happened why did servers across a whole bunch of different companies all fail at the same time we'll have a think about that and answer will come later 
 
 so i want to talk about time and time is very useful in distributed systems and in operating systems um just to remind you of a couple of uses of time for example in an operating system scheduler you want to context switch after a process has been running for 10 milliseconds maybe so you have to measure those 10 milliseconds if you want to send some kind of time out then of course you have to measure that time last lecture we talked about failure detectors which again rely on measuring whether you got a response or not within a certain period of time if you want to retry sending messages over a network again you probably want to wait for a certain time 
 
 all of those require measuring time other things that require measuring time are the performance measurements so how long has the process been running for how much cpu time has it been using if you want to profile a system in order to improve its performance that also relies on time measurement 
 
 in log files you probably want to record the date and time at which a certain event happened so for example a certain user logged in at a certain date at a certain time you want to record that in the log, in databases you might want to record when something happens so at which point did a user make a purchase for example what date at what time did that purchase occur 
 
 an interesting one is data that is only valid for a certain period of time so in a cache for example you might want data in the cache not to live forever but to be expired from the cache after it has been there for a while 
 
 so i'll give one concrete example of this we could use dns so the dns system for resolving domain names to ip addresses uh we can query so we can do something like this i'm going to query the computer lab website here and it's going to give me back the ip address of of that website and if you look at this answer here you can see in the second column there these numbers and these numbers are the time to live in seconds of these records so what this means is that you're allowed to cache the results of this dns query for a certain period of time here seven thousand seconds so that's about two hours or something like that and the results are allowed to be cached um but then after that time has elapsed then we need to refresh the query we need to rerun the query in order to get fresh data so that if somebody wants to change the dns record then it will eventually propagate to everywhere i can now actually rerun this a couple of seconds later and 
 
 see that now 7338 has gone down to 7293 because that number of seconds has elapsed while i was talking right now another interesting example of where um where time measurements happen is on a website so let's say here i have the computer lab website again and i'm connected to it via https which means that it has here a certificate so a tls certificate which is used as a mechanism to check that we're actually talking to the correct server not to some fake server that is trying to impersonate this website and if i view the certificate well again a certificate is valid only for a certain period of time so it has an expiry date here so this certificate re expires on the 2nd of november 2020 i'm recording this video here at the end of september 2020 so at the time when i'm speaking here the certificate has got just over a month still left before it expires and so it will get renewed from time to time every couple of months so that it keeps keeps being fresh but here again this requires my c in order for my computer to check whether the certificate is valid my computer needs to know what the current data is because otherwise the computer won't be able to tell are we within the validity period of this certificate or not so that's another interesting use of time. 
 
 and then finally we use time measurements in order to determine in a distributed system in which order certain events occurred and i will talk about that more later in this lecture so there are two types of clock that we encounter in distributed systems and we distinguish them as called physical and logical clocks 
 
 physical clocks are the type of clocks that you know from everyday usage they count the number of seconds that have elapsed they tell you what time of day it is and what date it is and that's the type of clock that we're talking about in this lecture logical clocks i will come to in the next lecture now just a little terminology clarification the term clock is also used in digital electronics and you've come across it there where it means a signal which produces pulses of ones and zeros at a certain regular frequency in distributed systems we use the word clock in a slightly different way so the meaning in distributed systems is a clock is something that you can ask for a timestamp so it tells you what the current time is and the current time is represented as a timestamp which might be the current date and time 
 
 so the way that most computers implement clocks nowadays is using quartz 
 
 quartz crystals 
 
 so this is literally a piece of quartz typically not a natural quartz crystal but an artificially grown one but it's still silicon dioxide and it's cut to a certain size and into a certain shape using lasers and it then mechanically vibrates so it mechanically resonates at a certain frequency and the frequency at which it resonates can be tuned by cutting off bits of the crystal using lasers now quartz is also a piezoelectric material which means that if you apply an electric field to it it induces a mechanical strain in the material and also the other way if you apply a force to it then it uh it creates an electric field and so you can have you can use this interplay between the mechanical motion and the electric field in order to create a fairly accurate oscillator that resonates at a fairly accurate frequency and so there's a little bit of electronics around the quartz crystal but essentially it produces uh a a signal with a certain fixed frequency now this frequency is is quite predictable and this makes quartz clocks quite accurate but are certainly not perfect because there are always going to be certain manufacturing differences between one crystal and another they won't oscillate at precisely the same frequency there will be a little bit of an error moreover the resonant frequency of a quartz crystal actually depends on the temperature and so the uh the the crystals that are used for quartz oscillators are tuned and they're selected and created in such a way that they are 
 
 their frequency is quite stable around room temperature around 20 to 25 degrees c um but as you deviate from this temperature significantly there's actually a quadratic decrease in the clock speed and so uh if you if you're in a very hot server room for example uh where you know you might reach significantly higher temperatures than your typical room temperature then this actually can have a significant impact on on the frequency at which the the clock is running 
 
 so the clock speed is measured in parts per million usually this is just like percent but rather than dividing by 100 we divide by a million and so you can work out like if you have one ppm error that would mean that the clock goes wrong by about 32 seconds per year now most quartz clocks will be like maybe 20 ppm or something like that order of magnitude of course depending on the temperature um as a rule of thumb probably most clock errors will be below 50 ppm now if that is not accurate for you not not accurate enough for you you can use an atomic clock atomic clocks are much much much more accurate and they are based on quantum mechanical effects so they actually use cesium atoms of a certain isotope of cesium and they if you remember any quantum mechanics uh atoms have discrete energy levels the difference between those energy levels corresponds to certain resonant frequencies of the atom and there's one particular energy transition which is at a fairly friendly to measure frequency of about nine gigahertz so you get about nine oscillations of this per second and this is actually how the second is now defined so the si unit of one second is defined to be exactly 9 billion 192 million blah blah periods of this particular signal generated from the this particular resonant frequency of cesium atoms 
 
 now this is incredibly precise um of course the clocks are not that cheap but you can just buy a clock off the shelf if you have the money 
 
 i'm not entirely sure exactly how much they cost but these were sort of the best estimates i was able to get off the internet 
 
 and um well if you have an atomic clock you can do some interesting things with it like you can use you can build gps for example so um if you want a very precise clock signal one way of getting that clock is actually to use gps 
 
 so the same system that you use on your smartphone to tell you where you are right now on a map it works by having a bunch of satellites that orbit the earth and each satellite carries an atomic lock that broadcasts its current clock and its current location uh periodically 
 
 and so the gps receiver it receives the signals from several of these satellites it calculates the time difference between when the signal was sent by the satellite and when the signal was received by your phone and from the time distance and the speed of light it can work out the actual distance in space between you and the satellite and from that it can work out where you are now there's a lot of details that go into making this accurate but for our purposes well you know all we're actually interested in right now is time not location and you can use gps satellites as a very accurate way of of getting time and clocks now the this does rely on being able to actually pick up the signal from the satellite so if you're in a data center there's probably so much shielding and electromagnetic interference that you can't actually pick up the signal so you have to put an antenna on the roof of the data center but this is something that people actually do as a way of getting accurate clocks 
 
 so so much about how clocks actually work now how is time defined so you might have come across the term utc the universal coordinated universal time which is the reference time that is used for all of our time zones we use nowadays how is utc actually defined we have to be precise about this and so you've probably come across the term gmt greenwich meantime which unfortunately the meaning of that has changed over time its original meaning was time based on astronomical observations so it was literally when does the stan the sun when is the sun in the south if you are looking at the sun from the greenwich observatory so you can literally go to greenwich in in southeast london and visit the observatory there and see the meridian at which it was defined that when the sun is in the south as seen from this particular place then it is noon now it varied the time varies a little bit over the course of the year so that way we actually average this over the course of the year but the idea is still this is time based on astronomical observations now i just said atomic clocks they define time using cesium atoms so using quantum mechanics and so this is now actually how time is defined the international atomic time is let's take atomic locks we take uh a couple of hundred atomic clocks spread around the world we synchronize those and we count exactly the number of oscillations we have from this cesium resonant frequency and that tells us how many seconds have elapsed now these two things don't unfortunately match up exactly so we have two different definitions of time one based on astronomy the other based on quantum mechanics and these two things don't exactly match up they're pretty close but especially the observations based on astronomy are problematic because the speed of the rotation is not actually entirely constant just actually the earth wobbles a little bit and sometimes it turns a little bit faster and sometimes it turns a little bit slower and this is affected by earthquakes and by tides and by all sorts of weird complicated effects and so the result is that well we want to use atomic time because that's much more precise than this wobbly earth time but at the same time we want our time to be consistent with how the earth rotates around its axis and so the compromise is utc the compromise is we take atomic time international atomic time and we apply some corrections to it based on astronomy and that will give us a time that is founded on quantum mechanics but still consistent with astronomical observations it's a bit of a complication but that's what we've ended up with and so this is how utc is defined and time zones and like all of the like summertime winter time all of these are defined as offsets to utc now and so like if you're on the east coast us for example you'll be in like utc plus five for example now how does this correction from atomic time to utc look like the answer is the correction takes the form of leap seconds so you've all heard of leap years before leap years are very familiar thing this is a different concept um but it's similarly weird it's even more weird actually 
 
 and so a leap second is an extra second that can be either inserted or removed on a certain date and so every year there are typically two dates on which a leap second mail may not happen and that is the 30th of june and the 31st of december in principle i think it can happen at the end of every month but these are the two months that are typically used and at that point uh a few months before the the leap second may or may not happen astronomers decide okay how fast has the earth been rotating for the last couple of months okay do we need to insert a second or not to keep the utc greatly consistent with the rotation of the earth and so depending on what the astronomers decide then the clock may or may not have an extra second and so this means actually that so if there's a second subtracted then there is no 23 59 59 second the clock goes 58 and then immediately jumps to zero after one second so the 59 second is simply skipped or we could have a regular second or we can have an additional second in which the clock goes from 59 59 to 60 and then to zero after two seconds so we've inserted an extra second at 23 59 and 60. now this sounds complicated and it is and unfortunately computers are not very good at dealing with this so there are two typical representations of time that are most commonly used in computer programs firstly unix time which is simply a number an integer that counts the number of seconds since an arbitrary point in time the first of the first of january 1970 was arbitrarily picked as this is called the unix epoch and we count the number of seconds except that unix time is defined as not counting the leap seconds or rather the standard simply doesn't say anything about leap seconds it's simply implied that well i don't know who cares about leap seconds whatever 
 
 but it is defined in terms of utc so it's not actually utc it's kind of an international atomic time actually rather than utc but everyone says it's utc so what is this thing also then there's this other format of representing dates and times which is iso8601 which is based on year month day hour minute seconds this is convenient because it's easy for humans to read but now it means we have to convert between these two representations and so conversion firstly needs to needs you to know the calendar so okay we know how the gregorian calendar works we have 365 days in a year except we add an extra 29th of february in leap years if the year is divisible by four but not if the year is divisible by 100 but if the year is divisible by 400 then we do add a leap day after all okay fine so that's our leap years but then actually in order to correctly convert these formats we should also take leap seconds into account because they also determine the num the number of seconds that have elapsed since the 1st of january 1917 because they've been i think over 20 leap seconds inserted since that point well how do you think software deals with these problems of leap seconds 
 
 you guessed it software ignores it software goes la la la la la there are no leap seconds i don't care and just hopes that the problem goes away unfortunately the problem does not go away and uh now of course some applications it doesn't really matter because you know one second here or there for many applications really doesn't doesn't make a big deal of difference you know if you want to have on your facebook status update at what time you posted the facebook status update if that's wrong by a second nobody's going to care 
 
 but in operating systems and distributed systems often we do actually rely on quite accurate time measurements with sub-second accuracy and in that case actually the difference of one second can be rather significant and that means we do actually have to care about these leap seconds which brings us to the solution of the little puzzle that i presented at the beginning of this lecture which is what is what on earth happened on the 30th of june 2012 for all of these systems to go out down at the same time well the answer was a leap second happened and there hadn't been a leap second for a couple of years before that and so during those years of course the linux kernel and all other software was updated and the bug was introduced and as a result there was actually a live lock condition sort of when the leap second happened the system went into live lock and so it was just spinning 100 cpu and not getting any useful work done and even rebooting the computers didn't actually help what the administrators figured out then was that you actually had to reset the system clock and that somehow cleared out the bad state in the linux kernel and allowed us to fix those computers again but you can imagine that that was a really bad day for administrators of these systems who rebooted the systems and they still didn't work now a solution is now more widely used which tries to get around this problem that most software does not know how to deal with leap seconds correctly and the solution is called smearing leap second 
 
 smearing which is rather than if we're going to insert a leap second rather than inserting it at one particular moment how about we just spread that leap second out over the course of a whole day so let's say for example 12 hours before and 12 hours after the leap second is supposed to be introduced we just slow down the clocks ever so slightly uh enough so that then in total uh one additional second has elapsed over the course of this period but without this discontinuity of of time where we've added that extra second which confuses all of the software and this is 
 
 it's kind of kind of a hack really it's not a very elegant solution but it might be pragmatically the best that we can come up with just given the problem of so much software is out there that doesn't know how to deal with leap seconds and realistically we're not going to manage to update all of that software so probably this smearing approach is the best we have but anyway that is the backstory of leap seconds and why they actually have quite a significant impact on our systems

# Distributed Systems 3.2: Clock synchronisation

next we're going to talk about clock synchronization so we've established every computer pretty much contains a quartz clock not an atomic clock because atomic clocks are too expensive and too bulky so what we need to do is make do with these less accurate quartz clocks and we have to somehow try and make the clocks reasonably accurate nevertheless so these quartz clocks will drift a little bit they because their rate does not match up exactly with what the correct clock tick rate should be and we end up with clock skew so clock skew is if we look at two different clocks at the same instant in time and we compare the time stamps from those clocks clocks use the difference between those two and we what what we want to do with clock synchronization is to minimize the skew as much as possible now in the types of networks that we have in asynchronous or partially synchronous networks it is not possible to reduce the clock skew to zero the best we can do is to reduce it as much as we can but there's always going to be a bit of an error tolerance remaining now the way that we typically do clock synchronization in practice is using a protocol called ntp the network time protocol there's also another protocol called ptp but we won't talk about that in this course and the way ntp works is that there's a server and we assume the server has some accurate clock source such as an atomic clock or gps receiver and clients can query the server and ask it for the server's current time and then the client will adjust its own time based on the time that it got from the server so ntp is very widely deployed almost all operating systems that are used nowadays have ntp built in so for example in macos the settings dialog looks like this here you can choose the ntp server here or type in your own in this case i've got time.euro.apple.com as my time server but most other operating systems will have a very similar looking dialog where also you can adjust and choose your ntp server if you want it now the way that ntp works is that servers are arranged into what are called strata 

so stratum 1 is just the accurate time sources that is atomic clocks or gps receivers stratum 1 is a server that is connected directly to a stratum 0 time source stratum 2 is a server that is not directly connected to an accurate time source but which gets its time from a stratum 1 server and stratum stratum 3 server gets its clock from a stratum 2 server and so on and so 

the whole bunch of statistical techniques and tricks that are used in order to try and improve the quality of our estimates of time so one thing that ntp does is for example to query multiple servers if they are available because it could be that one of those servers is misconfigured or it's got a fault or something and so it's reporting a wildly inaccurate time and so 

if you're querying three servers or five servers then you can to tell if there's one of the servers which is a real outlier and the other servers are all quite close together in that case ntp can exclude that outlier and just keep the data points from the servers that that seem to be reliable another technique that is used is to query a server not just once but multiple times over the course of several minutes and so that will then ensure that at least any random variations in network delay can hopefully get filtered out now if there's systematic variations in network delay having multiple samples won't help you but at least multiple samples will reduce the random error and with ntp if you have a good quality network connection it is possible to get your clock synchronized to the server within a couple of milliseconds uh skew if you are on a poor quality network connection over some kind of busy wi-fi over uh heavily loaded internet connection then the accuracy could be much much worse than that so you always have to be careful when when assuming synchronized clocks now let's have a look at how ntp estimates the clock skew between the client and the server it works by sending a message 

over a network again as usual so we have a request message that could send from the client to the server and what as the client is sending this message it records the clock according to the client's timestamp the timestamp t1 which is the timestamp at which the client sent out this message and it copies that timestamp t1 into the request message the ntp server when it receives that message it will also record the time according to the server's own clock at which it received that timestamp and we'll call that t2 at which it sorry at which it received that message we'll call that 

t2 now the server might take a little bit of time to process the message but eventually the server will reply and t3 is the timestamp according to the service clock at which the response got sent out 

so now the response is going to contain all three timestamps so far 

so t1 simply gets copied from the request over to the response the server doesn't do anything with t1 t2 and t3 came from the surface clock as the arrival time and the response time respectively and finally when the response is received by the client the client again records the timestamp according to the client's clock at when that response was received and so we have now four time stamps and from those time stamps we're going to try to work out what the skew is between the two clocks so first of all we can work out how long that the message is spent traveling through the network and we're going to call that the total network delay delta and that time has got to be t4 minus t1 so that is the total time that it's spent from the client's point of view from the time it sent the request to the time it received a response minus the time that the message was spent processing on the server so minus t3 minus two which is the processing time on the server and the remaining time has has got to be then the total time that was spent in the network by the response and the request taken together now what we don't know is the breakdown of those two how much time that the request spent in the network and how much time that the response spent in the net spend in a network if you want to work out that one-way network latency you need synchronized clocks and the whole point of this exercise here is that we don't have a synchronized clock we're trying to build a synchronized clock so we don't have a way of measuring that one-way network latency we can only measure the sum of the two network latencies put together but what we can do is just make an assumption that the network latency is symmetric in both directions so we're going to assume that the request latency is the same as the response latency and if this is true then the response latency will be delta over 2 because it's just going to be half the total delay so this means now we can estimate the timestamp that the server should have at the moment in time when the response is received by the client so from the client's point of view it's time t4 but we know that the server sent its response at t3 and we're going to estimate that the response spent delta over 2 traveling through the network and so we're going to estimate that at the time when the client receives the response the clock on the server says t3 plus delta over 2 that's our estimate of the server's clock now that we have an estimate of the surface clock we can estimate the clock skew because we can just take our estimates of the service clock minus t4 which is the client's clock and that will give us the instantaneous difference in time between the two clocks at that moment and then if you substitute in delta and simplify the expression you get this expression here which is our best estimate that we can do of what the clock skew is now that we have to skew between the two clocks the client can correct its own clock and tries to bring it in sync with the server and what the client does in that situation now depends on how big the clock skew is so firstly let's look at the case where the clock skew is fairly small so let's say theta is less than 125 milliseconds in this case what the client is going to do is to slightly speed up or slow down its clock as necessary in order to bring it in line with what the server is and so it's going to change its clock rate at at most by 500 ppm so at most by half a millisecond per second adjustment and so over the course of a couple of minutes this means that hopefully the client clock and the server clock will sort of drift together and converge towards the same state and this is called slewing the clock that is the term that ntp uses for this if the skew is too big between the client of the server then then uh ntp is going to step the clock which means it's simply going to forcibly adjust the clock um so even if if this might mean moving the clock backwards or moving it forward but it's just going to jump right to the time stamp estimated from the server clock and from then onwards it's going to try and do everything smoothly but there is this initial discontinuity of time where the client steps its clock and finally it could happen that ntp decides that the skew between the client and the server is so big that ntp refuses to adjust the clock it just says no i'm not going to do anything i'm going to assume that something has gone very wrong i don't know if the client's clock is very wrong or the server's clock is very wrong but this is just so bad i'm not going to do anything here it's going to leave the adjustment for the human operator to solve so this means now if you do have software that is relying on clocks being synchronized you have to be very careful to actually measure the clock skew between the clocks and make sure that it doesn't get too big because it could happen that an ntb client ends up in this panic state and just refuses to sync its server to sync its clock with the server and so you've got then an ntp client whose clock is way off it might be half an hour or more wrong compared to the server and ntp is not going to correct it so you do have to be very careful if you have software that assumes synchronized clocks this is an example of slewing in action so you can see here the red line here is the skew the offset between the two clocks and it starts off at about 10 milliseconds offset and then the correction gets applied so that it ends up being round about zero uh clock skew and the blue line is the the tick rate the at which the the client clock is running and so the client here has applied slewing up to about minus 45 ppm so that means that the quartz crystal in the client must have been a bit fast it was running a bit fast by about 45 ppm and by slowing down the the the quartz by 45 ppm now the ntp client has brought the tick rate of the client roughly in in line with the server so now both clocks are moving ahead at about the same rate and no longer drifting apart so this is very nice but the consequence of ntp is that you have to be very careful when writing certain pieces of code so this is a piece of code that is very likely going to occur in all sorts of different software where you have some function that does something do something here and you want to measure how long that function takes to run and so in order to measure that time you simply take a timestamp from the clock before you start the function and you take another timestamp after you finish the function and then you calculate the difference between the two this is an example here in java but this could just as well be in any other programming language it's not specific to java now what could happen is that ntp decides to step the clock right while you're in the middle of executing this do something function and the stepping the clock means that now the timestamp return returned by current time millies after the the do something is going to be somehow wildly different from what it was before so it could be that the time was time the clock was moved backwards in which case this difference in timestamps could end up being negative and who knows what your software is going to do if it measures a negative amount of time elapsed things could crash or things could go badly wrong in all sorts of interesting ways also it could be that this number ends up being far too large because if the client ntp client steps the clock forwards in that case now it's going to um it's going to have in time being much bigger than a much greater time stamp than it ought to be and so the difference will be greater than it ought to be so if you want to do this kind of time measurement it is not good to rely on a clock like current time millis instead what you should do is use a different api so java provides this other function here called system.nanotime and nanotime is designed for this kind of thing so there's the superficial difference current time millis uses milliseconds nano time uses nanoseconds that's just the superficial difference the real difference is that nanotime is what's called a monotonic clock and monotonic clock is one in which ntp stepping will not affect it so this clock is not going to suddenly jump forwards or backwards as the name name size as the name says monotonic clock means that it moves forward at a more or less constant rate slewing will still affect it because that improves the accuracy of the clock but it's not going to suddenly jump with a discontinuity and so using nanotime here to measure the time elapsed is the correct way of doing this so this difference between monotonic and time of day clocks is very important so the time of day clock is for example the java's current time millis which gives you the time elapsed since a fixed reference point in the case of unix timestamps it's this first of january 1970 epoch date whereas a monotonic clock the value you get back from it is some arbitrary time since for example this particular computer booted up so this means that the timestamp by itself doesn't really mean anything you can't send the timestamp over a network to another computer and compare those because two different computers will have booted up at different times and so their mono monotonic timestamps are simply not comparable but you can use the monotonic clock for time measurements because if you calculate the difference between two time stamps from a monotonic clock then the time will have moved forward at a near constant rate between those two timestamps and so that's a meaningful measure of time elapsed whereas if you do that sort of difference with time of day clocks then you are affected by by jumping due to ntp you're also affected by leap seconds potentially which we talked about earlier so these are very bad for measuring elapsed time but on the other hand time of day timestamps you can compare across different computers if you remember earlier the example i had of the tls certificate which was valid until a certain date if my computer wants to check whether that certificate is still valid well it has to have the accurate current date otherwise it's not going to be able to compare the timestamp in the certificate with the current timestamp on that computer so in this case we do have to use a time of day clock and do we do have to synchronize those clocks across multiple machines because otherwise we won't have accurate timestamps so as i said many programming languages and operating systems provide apis for this uh in linux for example there's the clock get time call and you can pass an argument to it say which tells it whether you want the real time clock which is the time of day clock or you want the monotonic clock but in other languages there will be similar apis for this you will have to check the api documentation but it is important to keep in mind this distinction if you do need to measure times it's not just about the resolution of the clocks but the distinction between a monotonic and non-monotonic clock is very important

# Distributed Systems 3.3: Causality and happens-before

in the last part of this lecture we are going to look at the relative ordering of different messages and different events that can happen in distributed system and how we might use time in this context 

so let's start with an example again let's start with an example of a discussion thread on the internet and you know one of those typical highbrow discussions where 

one user says "the moon is made of cheese" and another user responds to them saying "no you are wrong" 

so we are going to model this kind of discussion thread here let's say we have user1 uh sorry user a here who says the moon is made of cheese sends that message m1 to users b and c and we're going to just assume our usual system model of uh let's say reliable network links um but messages might be delayed or might be reordered as usual and so it can happen that user b receives uh message m1 fairly quickly and user c receives that message a little bit later just because it's been delayed a bit in the network that's fine 

now then user b responds to message one user b receives m1 and says no the moon is not made of cheese and sends that as message m2 back to user a and also to user c now what can happen is what you see in this diagram here is that user c actually receives m2 before receiving m1 

and this is kind of confusing because if you imagine user c is looking at this thread users he first sees oh no it isn't and then the moon is made of cheese so even though oh no it isn't really should be a reply to the moon is made of cheese we have ended up reordering those and we've got the reply before the thing that it's replying to 

this is pretty confusing so let's think about how we might be able to formalize this problem and how we can create algorithms that solve this problem 

so this is uh based on this idea that one thing happened before another i think we can agree that m1 happened before m2 because if m2 is a response to m1 then m1 must have happened first there's kind of some kind of logical time in the system here but let's see what happens if we attach timestamps to each message so let's say that when user a sends message m1 user a also uses a's local clock to generate a timestamp t1 and attaches timestamp t1 to the message m1 and then also when user b receives m1 and sends m2 user b gets a timestamp t2 from b's local clock and attaches that that timestamp to the m2 message that is sent to the other two nodes 

and now we're going to assume that these are of course physical time of day clocks we're going to assume that the clocks are synchronized using something like mtp but it could still happen even if synchronized if clocks are synchronized it could happen that the timestamp t2 is actually less than the timestamp t1 this could happen because the clock skew between two nodes in a system might be greater than the one-way network delay between those two nodes and even with ntp synchronization we cannot rule out the possibility that the clock skew is greater than the one-way network delay the not one-way network latency and so in this case here m1 is experiencing some kind of latency but that is that latency is smaller than the clock skew between users a and b and in that case if user's b clock is running slightly behind and uses a's clock is running slightly fast then you could end up with t2 being less than t1 and so our whole aim of this exercise was to ensure that messages get put in in the right order according to time but even using time here we have not actually been able to put the messages in the right order because the timestamp order is inconsistent with our understanding of which message is a reply to which other message so how do we solve this problem 

what we do in distributed systems is we use something called the happens before relation and so this is a mathematical model of activity that has happened in the distributed system and so when we're talking about activity in a distributed system first of all we need to define what are the things that happen so we'll say the things that happen are events an event can be just one process sorry one one node in the system making a local execution step one node doing something that can be an event or an event could be a message that one node sends to another 

so the sending of the message is one event and then the receiving of the message is another event if the message arrives then um the receiving would be another event and so now we can define a relation which is a pair a set of pairs of events that describes how those events relate to each other and this happens before relation is written as a a arrow b if a happened before b and we say that a happened before b if at least one of three things is true 

so the first thing is that the two events a and b happened in the same node and a occurred before b in that node's local execution order so that means we are here assuming that each node is a single threaded process that is just doing one thing after another so there's no ambiguity about the order in which things happened on a single node if there's a single thread then things only happen one after another and we can define exactly which thing happened first and which happens second so we're going to assume that for each node there's a strict total order of all of the events that happened on that particular node if we did wanted to support multi-threaded processes then we could have each thread being a separate node for the purposes of this model here 

so we can just assume single threads for now and and so we're going to say that a happened before b if they happened on the same node and they were executed a was executed before b that makes sense 

secondly we're going to say that a happened before b if a is the event that a certain message m was sent and b is the event that this same message was received 

so for the purpose of making this unambiguous we have to assume that messages are unique because otherwise you could have two different events for the sending of the same message which of course could happen in a real system but it makes the thing difficult to model mathematically 

so for simplicity's sake here we just assume that every message that is sent is unique and if we wanted to actually make messages unique in practice we could attach some kind of sequence number and uh the identifier of the node that sensed uh sent a message for example we could attach that to every message or we could pick a long random number for every message and that would be sufficient to make every message unique 

and so this again this happens before relationship makes sense because a message can only be received after it has been sent and so it makes sense for the sending of that particular message to happen before the receipt of that message okay 

so those are the first two clauses of happens before the third is simply if we can find some event c such that a happened before c and c happened before b then it must also be the case that a happened before b 

so this is simply taking the transitive closure of the first two points and extending the whole thing into what is called a partial order 

so a partial order is it behaves a bit like a a less than relationship between two things so it allows you to compare two things and say which one happened first but there might be some some things that are incomparable according to this order 

where we simply it is not the case that a happened before b or b happened before a the two are simply unrelated 
it is not the case that either one happened before the other and in that case we say that a and b are concurrent and we write it with this little double bar this parallel sign here 

so this is interesting here now for any two events a and b it turns out that uh there are only three possibilities either a happened before b or b happen before a or the two are concurrent and one of the exercises in the notes asks you to actually prove the fact that these are exactly the three possibilities that can happen 

so let's look at an example if that happens before relationship um so here we've got events are represented as these little black blobs and messages are sent over the network with these arrows as usual and we've got three nodes here and so we're going to build up the happens before relationship from the individual clauses and so 

firstly due to the order of events happening in a particular node well here node a executed a before b therefore a happened before b node b executed c before d so therefore c happened before d and node c executed e before f so therefore e happened before f okay 

so far so clear 

secondly now due to messages sent and received the sending of a message happens before the receipt of that message so therefore b happens before c because that is message m1 traveling over the network and also d happens before f because that is messaging message to traveling over the network so now we've got all of these relationships between some of the events now we extend this whole thing with the transitive closure and so due to the transitive closure for example a happened before c and a happened before d essentially what you can imagine here is we can take a path through this graph you can imagine any path that moves forward in time on a node or that moves from the sending of a message to the receipt of that message and then moves through other nodes and you can take any path through this graph as long as you're always moving forward in time then you will get from any a that happened before any other event and 

so here for example you can get from a all the way to f a happened before f because you can go from a to f by traversing these two um message sends um but for example you cannot get from a to e because going from a to e would require going backwards in the node order of c and that would not be allowed and so that means that for example a and e are concurrent so a did not happen before e e did not happen before a the two are simply concurrent which means they are independent one event did not know about the other when it happened concurrent does not literally mean simultaneous 

it doesn't mean happened literally at the same instant in time it just means the two events did not know about each other when they occurred and so therefore a is concurrent with e b is concurrent all a b c and d they're all concurrent to e but e and f are not concurrent of course because of the order of uh on on c on user c 

so that's the happens before relation and that happens before relation is very closely connected to the concept of causality in distributed systems in particular if a happened before b then it might be the case that a caused b or a influenced b in some way so there's some information flow that has happened from a to b whereas if the events a and b are concurrent we know that a cannot have caused b and b cannot have caused a there's no causal relationship between the two so this concept of causality is actually taken from physics um where typically uh people reason about events that happen far apart in space and the distance and the time that it takes the speed of light to travel between those things so if you have two events uh happening on on different planets say or even in different galaxies and so they are very far apart in space but you could have those events happening around about the same time they don't have to be exactly at the same time but they're happening fairly close together in time but fairly far apart in space then we can draw this space-time diagram here so we can draw this diagram where imagine that you send out a beam of light from event a at the time when event a occurs and you send it out in all directions and so then as time goes here downwards and space is from left to right so the this time sorry this this light just spreads through space at the speed of light and any event that happens within this cone here with it this is called a light cone that event might somehow be dependent on a but you can see b here is way outside of the light cone of a and also uh a is outside of the light cone of b so the information from uh from b at the time when b occurred could not possibly have got to a by the time a happened and likewise the information when a happened could not possibly have got to b by the time b happened simply because that would have required information to travel faster than the speed of light and we as far as we know in our universe it is not possible for information to travel faster than the speed of light so this event c here for example that could be influenced by a or b um but b and a cannot influence each other and so this is this this concept from physics is is very closely related to what we have in distributed systems in distributed systems which typically talk about messages flowing over a network rather than light traveling through the universe but essentially it's the same idea it's reasoning about which events could possibly have affected each other 

and once we have got this uh this potential causality and this happens before relationship we can now order events and so remember in our case of first the moon is made of cheese and then the reply to it oh no it's not what we want is for the moon is made of cheese to come first in this order of of the conversation thread and then the reply to come second in that order and here because we have a causal relationship between m1 which is the moon is made of ts and m2 which is the reply to m1 so there's a causal relationship between the two and so therefore a happened before b the message one happened before message two what we want is that any order that we put the messages into should be consistent with that so whenever a happened before b then a occurs before b in that causal order this is this is called a causal order that is it's a way of putting the events in the system into an order in such a way that they are consistent with causality that is if one thing happened before another thing then they appear in the correct order but if two things are concurrent then they could appear in either order because you know one could have happened before the other there's no real way of saying which one happened first 

so in that case they could be ordered arbitrarily so this is a very useful concept and we're going to use this in the next lecture when it comes to building upon this idea of the happens before relationship and making some actual distributed algorithms that implement this the last thing i will just point out is 

it's very easy to confuse the word causal with the word casual because just two letters are swept around i keep having to double check it myself as well so just that as a little detail to watch out for if you're writing about distributed systems you probably mean causal not casual so see you next time