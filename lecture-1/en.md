hello everybody my name is martin klepman and i'm going to be giving the next eight lectures on distributed systems this is the second half of the course on concurrent and distributed systems and so in the first half of this course you've seen a lot on concurrency that occurs within a single process so when you have especially when you have multiple threads within a single process that are performing operation concurrently you have seen how to deal with mutual exclusion for example and various algorithms for ensuring safe concurrency now in this kind of concurrent system you have all of the threads usually sharing a single address space and so you can just pass a variable from one thread to another thread and that variable can contain pointers or references to arbitrary objects and this will work because the memory addresses that one thread can access are the same as the memory addresses that another thread can access now when we move to distributed systems this changes so in distributed systems we still have concurrency we still have multiple processes and multiple threads performing operations concurrently potentially but we also have the additional challenge that now we're talking about not just a single program running on a single computer but multiple programs running on multiple computers where those computers are communicating via a network and this aspect that we are now introducing this network is part of what makes a distributed system distributed another aspect is also that we don't have a single shared address space anymore so a pointer that makes sense in one process if you send it over the network to another process running on a different computer that pointer will not necessarily make any sense uh to the recipient of that message and so we have to think about different ways of sharing data between these concurrent entities so um a definition of a distributed system somewhat joking definition provided by leslie lamport is that a distributed system is a system in which the failure of a computer you didn't even know existed can render your own computer unusable whether this is a good definition or not we can debate but leslie lamport is a bit of a legend in the area of distributed systems and we will see various aspects of work that he's done over the decades and of course lots of other people have done work in this area and we will see that over the course of these lectures so more generally i think i would define a distributed system as one in which you have got multiple computers or computing devices these devices might be smartphones they might be robots they might be self-driving cars they might be desktop computers there might be servers in the data center so any sort of computing device really and these computing devices are communicating by some kind of network which might be the internet and they are trying to achieve some kind of task together and the study of distributed systems is really the study of how do we coordinate the activities of these different devices in such a way that they achieve together the task that they are trying to achieve so i will start with a little bit of background uh first just the administrative things to get that done so uh first of all if you want any further background reading uh on this course hopefully the lecture notes will be reasonably self-contained but of course uh further detail is available in books if you are interested um there are several different styles of books that i've put here on the list so the textbook by van stein and tannenbaum is is a sort of systems level overview so this is it comes at distributed systems from quite an applied angle of real applications that real people use and discusses uh how these work and discusses the various implementation details of it it doesn't go as far into the theory as some of the other books but it's more practically oriented if you like the theory then the second book on this list is a good choice so the textbook by cashing gerrari and rodriguez is an excellent but quite detailed overview of distributed systems theory so it goes into a lot more depth than we have time to talk about in this course but if you want to read more about the theory this is an excellent book i also wrote a book in this area called designing data intensive applications this book is a bit more oriented towards distributed database systems so it's not just not just distributed systems in general there's a lot of the other databases content in there um but it's and this book is more oriented towards industrial software engineers so people who are working professionally with distributed databases will probably find this uh kind of book useful and finally there's the bacon and harris textbook which was already recommended for the concurrent systems part of this course which really provides the link between operating systems and distributed systems okay so this course is also connected to various other courses in the tripos most obviously concurrent systems that this course is part of also operating systems which you studied last year so all of the background that you had there on processes and inter-process communication and scheduling of processes all of that stuff is relevant for this course uh also the databases course is connected to distributed systems because as i mentioned just now many modern databases are in fact distributed and they use a lot of the techniques that we will talk about in this course and so using modern databases often involves using distributed systems as well there's a strong connection between distributed systems and computer networking because as i said distributed systems involve network communication generally the difference between the two courses is that the computer networking course is mostly about how do you actually get the bytes over the wire from one device to the other device so what do the network protocols look like that enable devices to communicate and then distributed systems builds on top of computer networking and saying okay assuming we now have this mechanism for devices to communicate how can we now ensure that these devices behave in the ways that we want there's connection to further java so there's programming exercises that involve a bit of distributed computing um the security aspects of distributed systems are very interesting and they are covered in a course in in easter term uh that's dedicated uh just a topic of security and finally next year's cloud computing course uh builds upon distributed systems because cloud computing is all about being able to flexibly process large amounts of data and if you have sufficiently large amounts of data you generally need a distributed system in order to process it okay so i gave a brief definition of uh what a distributed system is the next question is then why like why should we go to all of this effort of making a system distributed why can't we just use a single computer and keep things simple and well one reason is that some applications some types of things you want to do computers are inherently distributed so if you want to send a message from your phone to your friend's phone this inevitably involves two different phones and a network so this is a distributed system there's no way around it there's no way of building a messaging system that is not distributed if you want to be able to communicate across different devices and so building this type of software is one reason why we might be interested in distributed systems but many other reasons as well so another good reason for being interested in distributed systems is that it actually allows us to make systems more reliable and the reason for this is say you have multiple computers which are each performing part of some some job if one of those fails maybe one of them has to be rebooted for example or one of them has a hardware failure then maybe the remaining computers can take over the work from the failed computer and so now this allows the system as a whole to continue functioning even though one of the computers involved in it has actually gone down another reason we might want to make systems distributed is for better performance so for example in internet distributed systems you might have users all around the world you might have some users in the uk some users in the us some users in new zealand some users in south africa wherever and there are large distances between these different places and so network communication from one of these places to the others is always going to take a a little while uh you know you're talking at least 100 milliseconds simply because of the speed of light that it takes for communication to travel from one continent to another and so one reason why people are interested in distributed systems is to make systems faster by putting data closer to where the people are so if you have some users in multiple different continents you can have computers in multiple different continents and if you have each user communicating with the computer that is most local to them then you avoid the long distance intercontinental communication as part of the delays that are added to their communication so making systems distributed allows us to make them faster potentially and finally another reason why people build distributed systems is to solve bigger problems than they could with a single computer so some computing problems are simply very large scale so think of scientific computing examples like for example the uh the cern at the particle accelerator in switzerland that includes the large hadron collider they have a vast computing infrastructure involving a million cpu cores and god knows how many hard disks in order to just take all of the data that they're gathering from the particle accelerator and process it and analyze it and try to use this to discover new particles for example now this this scale of task would simply be not be possible to achieve on a single computer because there is no supercomputer that is big enough to be able to handle these vast volumes of data so simply solving this problem of analyzing such large volumes of data has to be done on a network of lots of small computers and and those computers have to distribute the work amongst them and they have to work together in order to achieve the tasks that the scientists are trying to do and so uh this is really um one of the another key area in which we can use distributed systems is to solve bigger problems now those are the advantages of making systems distributed there are unfortunately some significant disadvantages as well and the main disadvantage that you will be well familiar with is whenever you're trying to do something over a network that network might not be working for some reason and so everyone has experienced what it's like for the internet to be down or for your wi-fi signal to be weak or for yeah you're in some rural part of the country and your cellular data signal is weak and you're trying to load a map or something like that everyone has experienced this kind of frustration before and well the study of distributed systems is all about the study of such frustrations so we assume whenever we are building a distributed system uh that involves communication over a network that networks are not perfectly reliable and so it is always possible for communication to fail it is always possible that because because if it's a wi-fi network you might be out of range if it's a wired network somebody might have unplugged the wrong cable um if it's any any type of network it might just be temporarily overloaded and so it might be dropping messages maybe even somebody might be maliciously trying to interfere with the network and cause it to uh to drop packets maybe causing a denial of service attack for example there are many reasons why communication might not work from time to time and so we have to build systems that are robust so that even if communication is interrupted from time to time the system as a whole still functions in some correct way where of course we can define what we mean with correct but we want it to continue functioning another thing that can go wrong in distributed systems is that some of the processes the running the code might crash and for example if you have a system consisting of multiple computers and you reboot one of them you probably want the remaining computers to carry on the task of of serving user requests and so what we want here is that one of the processes cur is temporarily out of action and we want the system as a whole to still continue nevertheless and finally all of these failures can happen non-deterministically and that is we simply don't know when they happen they could happen at any moment unpredictably and we still have to ensure that the software works nevertheless so what we often strive for in distributed systems is what is called as what is known as fault tolerance which means that even if some part of the system is faulty some part of the system is not working the system as a whole still continues providing the service to the users and so this is one of the main challenges in distributed systems how do we make things in such a way that they can tolerate faults in fact making things distributed and fault tolerant is so difficult that a lot of people who work professionally on distributed systems think that oh well if you can solve a problem on a single computer it's basically easy so if you can solve a problem on a single computer you'll probably have a much better time just keeping it on one computer not over complicating things not going into a distributed system setting and so all of the problems this pandora's box of problems that arise with distributed systems well we should try and open that only if we actually have to but as we said earlier there are lots of good reasons why you might have to open that box.

in this section i will talk a bit more about the relationship between distributed systems and computer networking so in distributed systems generally any computing device that is involved in the system we call a node so a node could be a phone or a laptop or a server in a data center or any of the other things we talked about earlier and the fundamental abstraction of distributed systems the communication abstraction is that one node can send a message to another node that's it that's the entire basis of distributed system one node sends a message to another node and this captures all of the possible modes of communication that can happen now in practice of course there are lots of different types of network and different ways of getting a message from one node to another and so examples of that would be if you're at the university you will be probably using university provided wi-fi or college provided wi-fi uh if you're at home you probably have a home internet connection uh if you're sitting in a coffee shop you will probably be using the wi-fi there if you're out and about in town you will probably be using some cellular data on your phone and that's only like the network that you connect to directly on top of the those there are the backbone networks in that form the internet and there are lots of different types of network operated by all sorts of different companies some of those go via cables copper cables some of them are fiber optic cables some of them go underneath the sea some of them go by a satellite and so on all sorts of ways of getting messages from a to b in addition they're all sorts of physical communication mechanisms such as electrical pulses on a wire uh radio waves or lasers going down fiber optic cables or even hard drives in a van what hard drives in a van that's not a network connection well i will argue this is also a mechanism from getting messages from a to b so if what you have is a very large amount of data that you want to send to somebody else maybe to transfer it to a different data center then actually sending all of that data over the internet can be kind of slow and expensive and it can actually make more sense to load all of the data onto a bunch of hard drives load the box of hard drives into a van drive the van to the destination and when it gets to the destination you can then download all of the data back off the hard drives uh and store them in whatever system they need to be stored in and this people do this in practice actually and amazon web services for example which is a big provider of data center services they actually have this service where you can rent a box of hard drives from them and it will come as a in a career service and you can load all of your data onto it it takes about 50 terabytes or so on one of these boxes and send it back and so of course this is a very slow form of networking because it might take a day or a couple of days for the data to arrive but it is also quite a high bandwidth form of networking that is you can transfer large quantities of data and i would argue that from a distributed systems point of view this is just another messaging channel it's another way of getting a message from a to b distinction is just the latency and the bandwidth of those different networking channels so latency varies hugely depending on what sort of network you're looking at within the devices on your home wi-fi for example or within servers in the same data center you probably get like a millisecond maybe less than a millisecond depending on how congested the network is um latency that is the time that it takes to communicate from one device to another uh if you're going over the internet and you're talking to a server that is located on a different continent then it's probably more like on the order of 100 milliseconds of course hard drives in a van will probably take a day or a couple of days but still you know it's just another networking channel in terms of bandwidth this very hugely like a 3g phone uh might have like a megabit per second if you've got a good signal it might be more like 100 kilobits per second if you've got a poor signal um home broadband might be like 10 megabits of course it varies very much how close you are to the the next provider whether you have fiber and so on um roughly estimating the bandwidth of hard drives in a van well if you take one of these boxes and it takes a couple of days to do the whole loading data onto it getting it to the other place getting the data back off it again you can probably estimate it at roughly being a gigabit per second or something like that uh if you use one box of course you can send multiple boxes in which case you can increase that number those are just very rough numbers but just sort of to give you an idea of the order of magnitude that we're talking about with these so i will now like to show you an example of one concrete distributed system which is a system that you use every day and that system is the web and so the web we can now analyze through a distributed systems lens and see what actually happens uh when you load a website in a web browser and so what happens there is that we have two communicating entities first of all you've got the client which is the web browser running on your computer or your phone and you've got the server which is usually located somewhere in a data center and when the client wants to display a web page it makes a request so a request is just a message that gets sent over the network and that request is targeted at a particular server and it contains the path of the url that you're trying to load so you notice in the url you have the http maybe s double slash then comes the server name and then from the single slash onwards is the path and so the the bit before that first slash is uh the server name which is going to be the destination where we sent the message to and what follows after that is the path which is then contained within the message that we send to that destination and so that's message uh if you want to load a web page we call that a get request and it contains the path and the server then will respond with the contents of that web page and so that is probably an html page if it's just a plain web page but it could also be an image or it could be a video file it could be a pdf document or anything like that and so um what we have here is a simple protocol consisting of two messages a request from the client to the server and a response from the server back to the client containing the data that the client asked for so i'd like to now give you a little demo of what this actually looks like and so of course you know what a web browser looks like here i've loaded the course web page and i can scroll up and down and i can now record the messages that are sent and received over the network using a network capture tool so here i'm going to use a tool that's called charles and i'm going to put it into recording mode it's going to start recording and then i'm going to go here and just hit reload on the website and so here we go we've loaded the page again and now go back to charles and we can see that we've now accumulated a whole bunch of requests so each line here is one request message that was made from the web browser to the server and it also contains the response that was sent back from the server to the client and so here we can see for example this the first request here was for this path here which is the the path on the web browser you can see here in the url that matches up with this path uh you can see it's a get request to load a particular website um you can see a bunch of information like the user agent here for example is essentially the version of the web browser that i'm using so it identifies the client software version here this accept header this is uh indicates what file types the web browser understands so it understands html and various other image formats and stuff like that then there's a whole bunch of other stuff here like how it what sort of compression it accepts what sort of language i speak and so on so all sorts of stuff here and what you see in this panel here is the request message and then in the lower panel here you see the response message and here the response message to this here contains some html um and you can see like the whole content of the html page i can scroll down it's a bit boring okay and we can have a look at other requests here as well so you can see this here this looks like it's a picture that it's downloading and etc here's some css some style files and so on so what we have is this very simple request response messaging protocol at the conceptual level so at the conceptual level here uh at the distributed systems level we're just talking about one message one response now what happens at the underlying physical network level is a little bit more complicated and so uh we can look at what happens and the physical level by using a different network capture tool so i'm going to use a tool here that's called wireshark and this will this will actually capture rather than capturing at the http level capturing the request and response it's going to capture the individual network packets so let's see what happens here i'll start recording and then i'll go back to the web browser and i'll reload again and go back here and hit stop and here we now see oh a lot of activity again and so here in wireshark every line in this table is a single network packet and so here you can see that there's a packet sent from one ip address to another ip address so the 19192168 that is the device that is the ip address of my laptop on which i'm recording this right now this 128.2 etc that is the server that is the name of the web server um that of the computer lab website that i'm connecting to and so here you can see it's connecting using the tcp protocol don't worry too much about that you'll learn a lot more about tcp in the computer networking course but the bottom line of this is there's a lot of back and forth you can see and then here there's some encryption that happens because it's an https connection and you can see that here's the name of the website that i'm connecting to the server name that i'm connecting to and so on and so on the physical level what's happening here on the network is that we have all of these network packets going back and forth and the reason that we have lots of packets is that there's a maximum size of each packet and you can see here in this column it has the size the length in bytes of each packet and you can see that the length only goes up to about 1500 bytes here another with 1500 bytes but there are none that are bigger than that and that's because networks have this maximum size of a packet and so if you want to send a message that is greater than the size of a single packet you have to split it up into multiple packets and this is exactly what the tcp protocol does so the tcp http runs on top of tcp so http has this request message response message paradigm but a request might be bigger than a single network packet and a response is quite likely bigger than a single network packet as well so then http uses tcp underneath and tcp breaks down these big messages into small network packets that are small enough that the network can deliver them and then on the recipient side tcp puts all of the network packets back together again to give us one large chunk of bytes and so this is uh this is now like an important thing to keep in mind in distributed systems when we're talking about messages being sent and received we're not talking about individual packets because a message may well be bigger than a single network packet and so that message then has to be broken down into small network packets so the net the message is really a higher level conceptual um object that gets sent back and forth between between two nodes and how exactly this gets broken down to to the in on the packet level that's something that we leave to the computer networking people so for distributed systems point of view we can just assume that we have this mechanism through which we can send these requests and these responses here and we don't care too much about the details of how this is actually physically represented in terms of network packets we just assume that we have this communication mechanism.

so we saw the web as one example of a distributed system consisting of a client and a server let's look at another practical example which is imagine you're using some online shop to buy something and so what you want to do is you want to enter your credit card number on this shop after you've chosen the stuff you want to buy and then you check out and you pay with your credit card and then you get the goods shipped to you so what happens here is that the payment service that that actually processes this credit card payment is usually provided by a different company from the company that is running the online shop because processing credit card payments is a very specialized activity so it makes sense that they're companies that specialize in just doing credit card payments and another company specializes in actually providing the shop and the goods and so on so what happens when you enter your credit card number on some online shop is that the online shop will send a message to this payment service which is running on a different node provided by a different company and this message will contain the details of your card number and how much they want to charge to that card and various other information maybe your billing address and so on this will get sent to the payment service the payment service then does a whole lot of complicated stuff they talk to the card payment network such as restart visa or mastercard the card payment network then talks to the bank that issued your card they make sure that you actually have money in your account and then they make sure that the payment can be taken and if it's successful then they go through all of this in reverse and you know maybe they do extra checks to uh like make you enter a password or send you a text message or whatever it might be and eventually uh hopefully the payment service then sends a message back to the online shop indicating whether the payment was successful or not and so this is very concrete uh example of a distributed system that is really used like this every single day now let's have a look a bit at what the code might look like so imagine you are one of the programmers working on the side of the online shop so you're developing the software that runs the online shop and you're writing the code that is supposed to handle the credit card payments and talk to the payment service and so the code you write might look something like this here so let's assume that there's a card object in your in your code base and you can create a new instance of this card object and you can take give it the credit card number and the expiry date and the the three digits on the back and you can package all of this up as a card object and then you call this function so you have some object that has this payment service and you call the process payment method on this function and you give it the card that you want to charge and you give it the amount that you want to charge it and the currency in which you want to charge it and then depending on whether this is successful or not you then fulfill the order so this is quite interesting what is happening here because if you think about it the payment service is running on a different mode run by a different company it's not part of the code base of the online shop so what is happening here is when you call this process payment function the implementation of that function is not within your program the implementation is somewhere on another node at the other end of an internet connection and what is actually happening here is what what looks like a function called a method call is actually underneath being translated into some kind of network communication and this is called a remote procedure call maybe a remote function call would be a better name but remote procedure call is what this thing is typically called and so we're just going to stick with that name java calls the whole the same thing remote method invocation again just a different word for essentially the same idea and so let's have a look at how rpc a remote procedure call works so rpc is typically implemented with something called an rpc framework or it's called middleware sometimes this is a piece of software that performs the translation between the function call in your programming language and this message passing over the network and so when the on the code of the online shop calls this process payment function it can't directly call the function on a different node because your programming language doesn't support that normally instead the rpc framework provides what is called a stub so the stub function it has the same type signature and it looks the same as the function on the remote node that you want to call so you want to call this process payment function and what we make is this stub function that doesn't actually process the payment but what it does it sends a message to the service which then does process the payment so the online shop calls into this stub function here and the rpc client needs to take the arguments that were passed to that function and translate them into a message that can be sent over the network and this translation process from arguments in your programming language to message over the network is called marshalling and so marshalling or i call it encoding as well takes the function arguments and encodes it in some way that can be sent over the network so for example it might use json in this example it uses json it could use some kind of binary format the format it doesn't really matter but it becomes then essentially just a sequence of bytes that we can pack into a message send over the network and then on the recipient side the rpc server is going to receive this message and it's going to translate it back into a function call on the server side and so here now this is where the actual implementation of the process payment function lives and so here on the rpc server side now this function is going to get called and it's going to do whatever is necessary in order to make this payment happen and that will probably involve talking to the card network and the bank and updating some databases and doing a whole bunch of extra stuff and eventually this function will return and hopefully it will tell us whether the card payment was successful or not so the return value of this function again needs to be marshaled we do exactly the same in reverse so the rpc server marshals the return value of the function sends it back as a message m2 of the network the rpc client unmarshals it and turns it back into the data types of the programming language that you're using and then eventually the function returns and so what we've done now is to to kind of pretend that this what we're doing is calling a function locally but actually it's happening what's happening underneath is this communication uh via messages to another service so the ideal that we kind of want here is that the local function call uh sorry that the the function call to a different service looks just like a local function call because we know what functions in our programming language look like we would quite like the remote rpc to look just like that and this principle is called location transparency so the location of where your resource is located that is whether the objects that you're calling your process payment on whether that's an object in your own process in your local address space or whether it's somewhere on the other end of an internet connection we want that to be transparent we want not to be able to tell the difference between the two however actually reality doesn't look that simple because as i said in the beginning the trouble with networks is that they can fail so it can be that you send a message over the network and the message does not arrive you could send it again of course but then are you going to charge the credit card multiple times we have to be quite careful if we're going to send messages again so messages might be lost what do we do about retries messages also might be delayed so it might be that the message did actually get through but for some reason there was some networking hiccups somewhere that caused the message to be delayed by a while that could happen as well it could also happen that the service that is processing this function crashed in the middle of handling in the middle of executing our function in the way in that case it won't be able to send us back a response but it might have partially processed our request i guess we can use transactions here acid yes okay but you can see that a lot of open questions here and fundamentally it seems like actually making a function call to a remote resource is something totally different from calling a local function they're simply two different things we can make them look somewhat similar we can give the functions a similar type signature but but calling a remote function has all of these error cases that simply don't arise in local execution but that hasn't stopped people from trying to build rpc frameworks over a long time to try to look like uh you're calling a local function even though you're calling something on another node so it started right back in the 80s when the term rpc was first coined and like some microsystems had this thing and it was used to build nfs the network file system of which we'll see more later in the course um and then in the 1990s this was a very hot topic people then talked about object-oriented middleware and there was this thing called corba which was like really hot nowadays nobody uses it anymore um then there were a whole bunch of competing technologies like java's remote method invocation is kind of of a similar type to corba we won't go into the details of all of these i'm just mentioning the names here because you might encounter them in your careers and so it's good to at least have seen them before um and you know just as as recently as 2015 google brought out another rpc framework it's called grpc for google's rpc um and you know it's it's it's fine if you want to do rpc why not you can use it you can use something else it doesn't really matter what is common very common nowadays is actually something called rest this is stands for representational state transfer a bit of a mouthful but it's really a set of principles for how to use http people who are keen enthusiasts of rests don't like to think of rest as rpc they like to think of rest and rpc is two different philosophies but essentially they're the same kind of thing so essentially they're still about invoking code and causing something to happen in a remote service by making some network requests to it and packaging the whole thing up in some reasonably nice way in your programming language so one reason why this restful approach uh of building rpc was became so popular was that web browsers support making http requests so you can have some javascript code running within a web browser and this code can make http requests to a server and it can construct whatever data it wants to send in that request send out and it can receive the response back from the server this technique is sometimes also called ajax and it looks something like this so if i want to implement the this credit card payment example in javascript i might first of all create this object arcs containing the the arguments to the function call for the rpc so that will contain the amount and the currency and the card number and the billing address and so on and then i construct this request object which says which http method i want to use so post is the method that's used for submitting forms usually when you're changing some state on the server i'm now going to take the arguments and turn them into a json string using the json.stringify function and i can tell the server that json is the type of data that i'm providing so i'm providing the the file type essentially and then i can call this url which means actually sending an http request to this url example.com payments with all of the details specified above and then we have these two these two handlers down here so the then case has a function call back here which gets called if that network request receive resulted as in a successful response so if we got a response back from the server then this variable response here becomes that response and then we execute this code here so we can now look at the response that we got from the server and see whether the status code that it repli that it replies with indicates success or not so if it indicates success that means the response is probably json again so we can unmarshal that back into objects in javascript by calling this json function and then call the success function to indicate that we got a successful status back from the server otherwise if the status code was not success then we could call a failure function with the status code for example of course we can do more detailed error handling but that's just the general idea so this is the case where we got a response back from the server now of course messages can be lost and so it might be that we don't get a response back from the server and in this case the for example the request might just wait for 30 seconds and if it doesn't receive anything within 30 seconds it's going to say timeout we give up the message might have got through or might not we don't really know but we're going to give you a network error and that's what happens here so in this catch case here we have another callback function which gets called if the network request did not result in a response from the server and in that case i'm just going to call that failure function again and pass the error in in practice you would probably want to show the user message and explain that something went wrong anyway so this is the basics of of how you would do rpc um and this is how you would use a rest api over http in javascript and this pattern has become very popular as i said for web browsers so and most websites now will use this kind of technique to make http requests to the server without reloading the whole page and so it's just javascript running in your web browser that acts like a client-side program which is performing these network requests but the very similar techniques are also used for server-to-server communication and so this technique uh is particularly popular in large companies so in large enterprises you have these huge software systems which are running all of the operations of the company and these software systems are far too big and far too complex to have just like a single program running on one computer so simply because of the sheer complexity sometimes also because the large amounts of data that these things have to process um they are distributed systems so you have multiple nodes running on multiple computers which are all providing part of the infrastructure of this large organization call it a might be a bank or a retailer or whatever and uh and this uh this large uh bunch of software is broken up into what are called services and approach where you break down a large piece of software into services called a service oriented architecture or some people now a more modern term is to call it microservices and this is just having programs running on different nodes which communicate via rpc and so rpc here is the key mechanism that allows these uh these bits of software to interact with each other and so i'll tell you a little bit more about rpc in these kind of settings so we've seen it in the web browser but here in uh in service oriented architecture you're normally talking about services that are running within a data center and so they might be running on multiple different servers in the same data center but generally they are all services talking over the data center network so these are not services running on your end user device like your phone or your laptop but they are data center site services but we can use rpc equally well regardless of whether it's like end user devices talking to a server or servers talking to other servers what you do get in these large-scale enterprise systems is that they use a whole bunch of different programming languages because they have some old systems you know they might have some old systems written in cobol then they'll have some slightly newer systems written in c plus and have a bit newer systems written in java and then they'll have the latest systems in whatever is the latest most fashionable programming language right now and these systems need to talk to each other and so rpc can actually provide a mechanism for interoperability between these systems written in different programming languages now this does mean that you know if the function caller and the code being called if they're written in different programming languages you now have to make sure that the type signatures will match up somehow and so you have to perform some data type conversion and so this is often implemented using something called an interface definition language or idl and which is essentially a language for specifying the type signature or function calls in a way that is not specific to any one programming language so here's one example of what an idl looks like this example is taken from grpc the google rpc framework it uses an idl called protocol buffers the details are not important i just want to give you a bit of a flavor for what this looks like and so what you have here is you can have a specification of a message type so we can have a payment request message and a payment status message those are two different messages type and then down here we have the specification of a service so the payment service has an rpc offers an rpc function call which is called process payment it takes as argument a payment request and it returns as its return value payment status and then up here we can say what does a payment request consist of well a payment request consists of a card an amount and a currency and the card in turn consists of a card number and expiry date and the three digits on the back and the currency might be an enum indicating the possible values ignore those one two three four values here and the details of that are not important for the purposes of this course but you can see here i'm using data types like in 32 to indicate this is a 32-bit uh signed integer and you can that is like a fairly generic data type that you would expect most programming languages to support that kind of thing likewise here string data type is is very common um an enum you know if the language doesn't support enums you could translate it into just an integer or something like that boolean again is a common data type so you can argue you know should the card number be a string or should be a an integer with sufficient digits that you can have 16 digits whatever we can argue about that but you get the general principle this is a language independent specification of what the rpc can look like and the rpc framework can take this idl can take a specification and generate code in all of the in all of your favorite programming languages and so that's way that way then it can generate the stubs for both the rpc client and the rpc server that make it easy to write code that performs the rpc on both the caller side and the side of the service that's being called so that's that's our pc next time we will talk about a bit more about the fundamental issues of actually making reliable distributed systems.