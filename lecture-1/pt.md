Olá a todos, meu nome é Martin Klepman e darei as próximas oito palestras sobre sistemas distribuídos. Esta é a segunda metade do curso sobre sistemas concorrentes e distribuídos. Na primeira metade deste curso, você viu muito sobre a simultaneidade que ocorre dentro de um único processo. Então, quando você tem, especialmente quando você tem vários threads dentro de um único processo que estão executando operações simultaneamente, você viu como lidar com exclusão mútua, por exemplo, e vários algoritmos para garantir a simultaneidade segura. Agora, neste tipo de sistema concorrente, você tem todos os threads geralmente compartilhando um único espaço de endereço e, portanto, você pode simplesmente passar uma variável de um thread para outro thread e essa variável pode conter ponteiros ou referências a objetos arbitrários. Isso funcionará porque os endereços de memória que um thread pode acessar são os mesmos que os endereços de memória que outro thread pode acessar. Agora, quando mudamos para sistemas distribuídos, isso muda. Então, em sistemas distribuídos, ainda temos simultaneidade. Ainda temos vários processos e vários threads executando operações simultaneamente, potencialmente, mas também temos o desafio adicional de que agora estamos falando não apenas de um único programa em execução em um único computador, mas de vários programas em execução em vários computadores onde esses computadores se comunicam por meio de uma rede e esse aspecto que estamos introduzindo agora, essa rede, é parte do que torna um sistema distribuído distribuído.

Outro aspecto é que não temos mais um único espaço de endereço compartilhado, então um ponteiro que faz sentido em um processo, se você o enviar pela rede para outro processo em execução em um computador diferente, esse ponteiro não fará necessariamente sentido para o destinatário dessa mensagem e, portanto, temos que pensar em diferentes maneiras de compartilhar dados entre essas entidades simultâneas. Então, uma definição de um sistema distribuído, uma definição um tanto brincalhona fornecida por Leslie Lamport, é que um sistema distribuído é um sistema no qual a falha de um computador que você nem sabia que existia pode tornar seu próprio computador inutilizável. Se essa é uma boa definição ou não, podemos debater, mas Leslie Lamport é uma espécie de lenda na área de sistemas distribuídos e veremos vários aspectos do trabalho que ele fez ao longo das décadas e, claro, muitas outras pessoas trabalharam nessa área e veremos isso ao longo dessas palestras. 

De forma mais geral, acho que definiria um sistema distribuído como aquele em que você tem tem vários computadores ou dispositivos de computação, esses dispositivos podem ser smartphones, podem ser robôs, podem ser carros autônomos, podem ser computadores de mesa, pode haver servidores no data center, então qualquer tipo de dispositivo de computação realmente, e esses dispositivos de computação estão se comunicando por algum tipo de rede, que pode ser a internet, e eles estão tentando realizar algum tipo de tarefa juntos, e o estudo de sistemas distribuídos é realmente o estudo de como coordenamos as atividades desses diferentes dispositivos de forma que eles realizem juntos a tarefa que estão tentando realizar, então começarei com um pouco de contexto, primeiro apenas as coisas administrativas para fazer isso, então, primeiro de tudo, se você quiser mais leitura de referência sobre este curso, espero que as notas da aula sejam razoavelmente independentes, mas é claro que mais detalhes estão disponíveis em livros, se você estiver interessado. 

Há vários estilos diferentes de livros que coloquei aqui na lista, então o livro didático de van stein e tannenbaum é uma espécie de visão geral do nível de sistemas, então ele aborda sistemas distribuídos de um ângulo bastante aplicado de aplicativos reais que pessoas reais usam e discute como eles funcionam e discute os vários detalhes de implementação, não se aprofunda tanto na teoria quanto alguns dos outros livros, mas é mais voltado para a prática. Se você gosta da teoria, o segundo livro desta lista é uma boa escolha. O livro didático de Cashing Gerrari e Rodriguez é uma excelente, mas bastante detalhada, visão geral da teoria de sistemas distribuídos, então ele se aprofunda muito mais do que temos tempo para falar neste curso, mas se você quiser ler mais sobre a teoria, este é um livro excelente. Eu também escrevi um livro nesta área chamado "Projetando aplicativos com uso intensivo de dados". 

Este livro é um pouco mais voltado para sistemas de banco de dados distribuídos, então não se trata apenas de sistemas distribuídos em geral, há muito conteúdo sobre outros bancos de dados lá, mas é e este livro é mais voltado para engenheiros de software industrial, então as pessoas que trabalham profissionalmente com bancos de dados distribuídos provavelmente acharão este tipo de livro útil. E, finalmente, há o livro didático de Bacon e Harris, que já foi recomendado para a parte de sistemas concorrentes deste curso, que realmente fornece o link entre sistemas operacionais e sistemas distribuídos. Ok, então este curso também está conectado a vários outros cursos no Tripos, obviamente, sistemas concorrentes dos quais este curso faz parte, também sistemas operacionais que você estudou no ano passado, então todo o conhecimento que você teve sobre processos, comunicação entre processos e agendamento de processos, tudo isso é relevante para este curso. 

Além disso, o curso de bancos de dados está conectado a sistemas distribuídos porque, como mencionei há pouco, muitos bancos de dados modernos são, na verdade, distribuídos e usam muitas das técnicas sobre as quais falaremos neste curso. Portanto, usar bancos de dados modernos geralmente envolve o uso de sistemas distribuídos. Há uma forte conexão entre sistemas distribuídos e redes de computadores porque, como eu disse, sistemas distribuídos envolvem comunicação de rede. Geralmente, a diferença entre os dois cursos é que o curso de redes de computadores é principalmente sobre como você realmente obtém os bytes através do fio de um dispositivo para o outro. Então, como são os protocolos de rede que permitem que os dispositivos se comuniquem? E então os sistemas distribuídos são construídos sobre redes de computadores e dizem: "Ok, supondo que agora temos esse mecanismo para os dispositivos se comunicarem, como podemos garantir que esses dispositivos se comportem da maneira que queremos?". 

Há conexão com Java, então há exercícios de programação que envolvem um pouco de computação distribuída. Os aspectos de segurança dos sistemas distribuídos são muito interessantes e eles são... Abordado em um curso no semestre da Páscoa, que é dedicado, apenas um tópico de segurança e, finalmente, o curso de computação em nuvem do próximo ano, que se baseia em sistemas distribuídos, porque a computação em nuvem tem tudo a ver com a capacidade de processar grandes quantidades de dados de forma flexível e, se você tiver quantidades de dados suficientemente grandes, geralmente precisará de um sistema distribuído para processá-los. Ok, então dei uma breve definição do que é um sistema distribuído. A próxima pergunta é: por que, por que deveríamos fazer todo esse esforço para tornar um sistema distribuído? Por que não podemos simplesmente usar um único computador e manter as coisas simples? Bem, um dos motivos é que alguns aplicativos, alguns tipos de coisas que você deseja fazer, os computadores são inerentemente distribuídos. Então, se você quiser enviar uma mensagem do seu telefone para o telefone do seu amigo, isso inevitavelmente envolve dois telefones diferentes e uma rede. Portanto, este é um sistema distribuído. Não há como contornar isso. Não há como construir um sistema de mensagens que não seja distribuído se você quiser se comunicar entre diferentes dispositivos. 

Portanto, construir esse tipo de software é um dos motivos pelos quais podemos estar interessados ​​em sistemas distribuídos, mas há muitos outros motivos também. Outro bom motivo para estar interessado em sistemas distribuídos. sistemas é que isso realmente nos permite tornar os sistemas mais confiáveis ​​e a razão para isso é que digamos que você tem vários computadores, cada um executando parte de alguma tarefa. Se um deles falhar, talvez um deles precise ser reiniciado, por exemplo, ou um deles tiver uma falha de hardware, então talvez os computadores restantes possam assumir o trabalho do computador com falha e, assim, agora isso permite que o sistema como um todo continue funcionando, mesmo que um dos computadores envolvidos tenha realmente parado. Outra razão pela qual podemos querer tornar os sistemas distribuídos é para melhor desempenho. 

Por exemplo, em sistemas distribuídos pela Internet, você pode ter usuários em todo o mundo. Você pode ter alguns usuários no Reino Unido, alguns usuários nos EUA, alguns usuários na Nova Zelândia, alguns usuários na África do Sul, onde quer que seja. E há grandes distâncias entre esses diferentes lugares. Portanto, a comunicação de rede de um desses lugares para os outros sempre levará um pouco de tempo. Você sabe que está falando de pelo menos 100 milissegundos, simplesmente por causa da velocidade da luz que leva para a comunicação viajar de um continente para outro. Então, uma das razões pelas quais as pessoas estão interessadas em sistemas distribuídos é para tornar os sistemas mais rápidos, colocando os dados mais perto de onde as pessoas são assim se você tem alguns usuários em vários continentes diferentes você pode ter computadores em vários continentes diferentes e se você tem cada usuário se comunicando com o computador que é mais local para eles, então você evita a comunicação intercontinental de longa distância como parte dos atrasos que são adicionados à sua comunicação, então fazer sistemas distribuídos nos permite torná-los mais rápidos potencialmente e, finalmente, outra razão pela qual as pessoas constroem sistemas distribuídos é para resolver problemas maiores do que eles poderiam com um único computador, então alguns problemas de computação são simplesmente de grande escala, então pense em exemplos de computação científica como, por exemplo, o CERN no acelerador de partículas na Suíça, que inclui o Grande Colisor de Hádrons. Eles têm uma vasta infraestrutura de computação envolvendo um milhão de núcleos de CPU e Deus sabe quantos discos rígidos para simplesmente pegar todos os dados que eles estão coletando do acelerador de partículas e processá-los e analisá-los e tentar usar isso para descobrir novas partículas, por exemplo, agora essa escala de tarefa simplesmente não seria possível de alcançar em um único computador porque não há supercomputador que seja grande o suficiente para ser capaz de lidar com esses vastos volumes de dados, então simplesmente resolver esse problema de analisar esses grandes volumes de dados tem que ser feito em uma rede de vários computadores pequenos e esses computadores têm que distribuir o trabalho entre eles e eles têm que trabalhar juntos para realizar as tarefas que os cientistas estão tentando fazer e então, uh, esta é realmente uma das outras áreas-chave em que podemos usar sistemas distribuídos é para resolver problemas maiores. Agora, essas são as vantagens de tornar os sistemas distribuídos. Infelizmente, também existem algumas desvantagens significativas. 

A principal desvantagem com a qual você estará bem familiarizado é que sempre que você estiver tentando fazer algo em uma rede, essa rede pode não estar funcionando por algum motivo. Então, todo mundo já experimentou o que é a internet cair ou o sinal do seu wi-fi estar fraco ou, sim, você está em alguma parte rural do país e o sinal de dados do seu celular está fraco e você está tentando carregar um mapa ou algo assim. Todo mundo já experimentou esse tipo de frustração antes. Bem, o estudo de sistemas distribuídos é sobre o estudo dessas frustrações. Então, presumimos que sempre que estamos construindo um sistema distribuído que envolve comunicação em uma rede, as redes não são perfeitamente confiáveis ​​e, portanto, é sempre possível que a comunicação falhe. 

É sempre possível que, porque se é uma rede wi-fi, você pode estar fora de alcance, se for uma rede com fio, alguém pode ter desconectado o cabo errado, se for qualquer tipo de rede, ela pode estar temporariamente sobrecarregada e, portanto, pode estar perdendo mensagens, talvez até mesmo alguém possa estar tentando interferir maliciosamente na rede e fazer com que ela perca pacotes, talvez causando um ataque de negação de serviço, por exemplo, há muitos motivos pelos quais a comunicação pode não funcionar de vez em quando, então temos que construir sistemas robustos para que, mesmo que a comunicação seja interrompida de vez em quando, o sistema como um todo ainda funcione de alguma forma correta, onde, é claro, podemos definir o que queremos dizer com correto, mas queremos que ele continue funcionando. 

Outra coisa que pode dar errado em sistemas distribuídos é que alguns dos processos que executam o código podem travar e, por exemplo, se você tiver um sistema que consiste em vários computadores e reiniciar um deles, provavelmente desejará que os computadores restantes continuem a tarefa de atender às solicitações do usuário e, portanto, o que queremos aqui é que um dos processos atuais esteja temporariamente fora de ação e queremos que o sistema como um todo continue, no entanto, e, finalmente, todas essas falhas podem acontecem de forma não determinística e isso é que nós simplesmente não sabemos quando eles acontecem, eles podem acontecer a qualquer momento de forma imprevisível e ainda temos que garantir que o software funcione, no entanto, o que frequentemente buscamos em sistemas distribuídos é o que é chamado de tolerância a falhas, o que significa que mesmo que alguma parte do sistema esteja com defeito, alguma parte do sistema não esteja funcionando, o sistema como um todo continua fornecendo o serviço aos usuários e, portanto, este é um dos principais desafios em sistemas distribuídos, como fazemos as coisas de forma que possam tolerar falhas? Na verdade, tornar as coisas distribuídas e tolerantes a falhas é tão difícil que muitas pessoas que trabalham profissionalmente em sistemas distribuídos pensam que, bem, se você pode resolver um problema em um único computador, é basicamente fácil, então se você pode resolver um problema em um único computador, provavelmente terá um tempo muito melhor apenas mantendo-o em um computador, não complicando demais as coisas, não entrando em uma configuração de sistema distribuído e, portanto, todos os problemas, esta caixa de Pandora de problemas que surgem com sistemas distribuídos, bem, devemos tentar abrir isso apenas se realmente precisarmos, mas como dissemos antes, há muitos boas razões pelas quais você pode ter que abrir aquela caixa.

Nesta seção, falarei um pouco mais sobre a relação entre sistemas distribuídos e redes de computadores. Em sistemas distribuídos, geralmente, qualquer dispositivo de computação envolvido no sistema chamamos de nó. Um nó pode ser um telefone, um laptop, um servidor em um data center ou qualquer uma das outras coisas sobre as quais falamos anteriormente. A abstração fundamental dos sistemas distribuídos é a abstração da comunicação, que é o que um nó pode enviar uma mensagem para outro nó. Essa é toda a base do sistema distribuído. Um nó envia uma mensagem para outro nó. E isso captura todos os modos possíveis de comunicação que podem acontecer agora. Na prática, é claro, existem muitos tipos diferentes de rede e maneiras diferentes de enviar uma mensagem de um nó para outro. Exemplos disso seriam: se você estiver na universidade, provavelmente usará o Wi-Fi fornecido pela universidade ou pela faculdade. Se você estiver em casa, provavelmente terá uma conexão de internet em casa. Se estiver sentado em uma cafeteria, provavelmente usará o Wi-Fi de lá. Se estiver fora de casa, provavelmente usará alguns dados de celular no seu telefone. E isso é apenas como... rede à qual você se conecta diretamente em cima daquelas, existem as redes de backbone que formam a internet e há muitos tipos diferentes de redes operadas por todos os tipos de empresas diferentes, algumas delas vão por cabos, cabos de cobre, algumas delas são cabos de fibra ótica, algumas delas vão por baixo do mar, algumas delas vão por satélite e assim por diante, todos os tipos de maneiras de obter mensagens de A para B, além disso, são todos os tipos de mecanismos de comunicação física, como pulsos elétricos em um fio, ondas de rádio ou lasers descendo por cabos de fibra ótica ou até mesmo discos rígidos em uma van, quais discos rígidos em uma van, isso não é uma conexão de rede, bem, eu argumentaria que este também é um mecanismo para obter mensagens de A para B, então se o que você tem é uma quantidade muito grande de dados que deseja enviar para outra pessoa, talvez para transferi-los para um data center diferente, então enviar todos esses dados pela internet pode ser meio lento e caro e pode realmente fazer mais sentido carregar todos os dados em um monte de discos rígidos, carregar a caixa de discos rígidos em uma van, dirigir a van até o destino e quando chegar ao destino, você pode então baixar todos os dados de volta dos discos rígidos e armazená-los em qualquer sistema em que eles precisam ser armazenados e essas pessoas fazem isso na prática, na verdade, e a Amazon Web Services, por exemplo, que é uma grande provedora de serviços de data center, eles realmente têm esse serviço onde você pode alugar uma caixa de discos rígidos deles e isso virá como um serviço de carreira e você pode carregar todos os seus dados nele, leva cerca de 50 terabytes ou mais em uma dessas caixas e enviá-lo de volta e, portanto, é claro que esta é uma forma muito lenta de rede porque pode levar um dia ou alguns dias para os dados chegarem, mas também é uma forma de rede de alta largura de banda, ou seja, você pode transferir grandes quantidades de dados e eu diria que, do ponto de vista de sistemas distribuídos, este é apenas outro canal de mensagens, é outra maneira de enviar uma mensagem de A para B. A distinção é apenas a latência e a largura de banda desses diferentes canais de rede, então a latência varia enormemente dependendo do tipo de rede que você está olhando dentro dos dispositivos em seu wi-fi doméstico, por exemplo, ou dentro de servidores no mesmo data center, você provavelmente obtém um milissegundo, talvez menos do que um milissegundo dependendo de quão congestionada a rede está, latência, que é o tempo que leva para se comunicar de um dispositivo para outro. Se você estiver acessando a Internet e estiver falando com um servidor localizado em um continente diferente, provavelmente é algo em torno de 100 milissegundos. É claro que os discos rígidos em uma van provavelmente levarão um dia ou alguns dias, mas ainda assim você sabe que é apenas mais um canal de rede em termos de largura de banda, isso é muito grande, como um telefone 3G, pode ter algo como um megabit por segundo se você tiver um bom sinal, pode ser algo como 100 quilobits por segundo se você tiver um sinal ruim. A banda larga doméstica pode ser como 10 megabits, claro, varia muito, quão perto você está do próximo provedor, se você tem fibra e assim por diante. Estimando aproximadamente a largura de banda dos discos rígidos em uma van, bem, se você pegar uma dessas caixas e levar alguns dias para fazer todo o carregamento de dados nela, levá-la para o outro lugar e obter os dados de volta, você provavelmente pode estimar em aproximadamente um gigabit por segundo ou algo assim, se você usar uma caixa, é claro que você pode enviar várias caixas, nesse caso você pode aumentar esse número. Esses são apenas números aproximados, mas apenas para dar uma ideia da ordem de magnitude da qual estamos falando com eles. Agora, gostaria de mostrar um exemplo de um sistema distribuído concreto, que é um sistema que você usa todos os dias e esse sistema é a web. Agora podemos analisar a web através de uma lente de sistemas distribuídos e ver o que realmente acontece quando você carrega um site em um navegador da web. O que acontece lá é que temos duas entidades se comunicando. Primeiro de tudo, você tem o cliente, que é o navegador da web em execução no seu computador ou telefone, e você tem o servidor, que geralmente está localizado em algum lugar em um data center. Quando o cliente deseja exibir uma página da web, ele faz uma solicitação. Uma solicitação é apenas uma mensagem enviada pela rede e essa solicitação é direcionada a um servidor específico e contém o caminho da URL que você está tentando carregar. Observe que na URL você tem o http, talvez uma barra dupla, e então vem o nome do servidor e então da barra simples em diante é o caminho e então o bit antes dessa primeira barra é uh o nome do servidor que será o destino para onde enviamos a mensagem e o que vem depois disso é o caminho que está contido na mensagem que enviamos para esse destino e então essa é a mensagem uh se você quiser carregar uma página da web, chamamos isso de solicitação GET e ela contém o caminho e o servidor responderá com o conteúdo dessa página da web e então provavelmente é uma página HTML se for apenas uma página da web simples, mas também pode ser uma imagem ou um arquivo de vídeo, pode ser um documento PDF ou algo assim e então, o que temos aqui é um protocolo simples que consiste em duas mensagens, uma solicitação do cliente para o servidor e uma resposta do servidor de volta para o cliente contendo os dados que o cliente solicitou, então eu gostaria de agora dar a vocês uma pequena demonstração de como isso realmente se parece e então é claro que vocês sabem como é um navegador da web aqui eu carreguei a página da web do curso e posso rolar para cima e para baixo e agora posso gravar o mensagens que são enviadas e recebidas pela rede usando uma ferramenta de captura de rede, então aqui vou usar uma ferramenta chamada Charles e vou colocá-la no modo de gravação. Ela vai começar a gravar e então vou aqui e apenas clicar em recarregar no site e então aqui vamos nós carregamos a página novamente e agora voltamos para Charles e podemos ver que acumulamos um monte de solicitações, então cada linha aqui é uma mensagem de solicitação que foi feita do navegador da web para o servidor e também contém a resposta que foi enviada de volta do servidor para o cliente e então aqui podemos ver, por exemplo, esta a primeira solicitação aqui foi para este caminho aqui, que é o caminho no navegador da web, você pode ver aqui na URL que corresponde a este caminho, uh, você pode ver que é uma solicitação GET para carregar um site específico, hum, você pode ver um monte de informações como o agente do usuário aqui, por exemplo, é essencialmente a versão do navegador da web que estou usando, então ele identifica a versão do software cliente aqui, este cabeçalho de aceitação, isto é, uh, indica quais tipos de arquivo o navegador da web entende, então ele Entende HTML e vários outros formatos de imagem e coisas assim, então há um monte de outras coisas aqui, como que tipo de compressão ele aceita, que tipo de linguagem eu falo e assim por diante, então todos os tipos de coisas aqui e o que você vê neste painel aqui é a mensagem de solicitação e então no painel inferior aqui você vê a mensagem de resposta e aqui a mensagem de resposta para isso aqui contém algum HTML, hum, e você pode ver todo o conteúdo da página HTML, eu posso rolar para baixo, é um pouco chato, ok, e podemos dar uma olhada em outras solicitações aqui também, então você pode ver isso aqui, parece que é uma imagem que está sendo baixada e etc. Aqui está algum CSS, alguns arquivos de estilo e assim por diante, então o que temos é este protocolo de mensagens de solicitação de resposta muito simples no nível conceitual, então no nível conceitual aqui, uh, no nível de sistemas distribuídos, estamos falando apenas de uma mensagem, uma resposta. Agora, o que acontece no nível da rede física subjacente é um pouco mais complicado e então, uh, podemos ver o que acontece no nível físico usando uma ferramenta de captura de rede diferente, então vou usar uma ferramenta aqui Isso é chamado de Wireshark e isso vai capturar em vez de capturar no nível http, capturando a solicitação e a resposta, vai capturar os pacotes de rede individuais, então vamos ver o que acontece aqui. Vou começar a gravar e depois voltarei ao navegador da web, recarregarei novamente, voltarei aqui e clicarei em parar. Aqui vemos muita atividade novamente. Então, aqui no Wireshark, cada linha nesta tabela é um único pacote de rede. Aqui você pode ver que há um pacote enviado de um endereço IP para outro endereço IP, então o 19192168 é o dispositivo, que é o endereço IP do meu laptop no qual estou gravando isso agora. Este 128.2 etc. é o servidor, que é o nome do servidor web, do site do laboratório de informática ao qual estou me conectando. Aqui você pode ver que ele está se conectando usando o protocolo TCP. Não se preocupe muito com isso. Você aprenderá muito mais sobre TCP no curso de rede de computadores, mas o ponto principal disso é que há um Muitas idas e vindas, você pode ver, e aqui há alguma criptografia que acontece porque é uma conexão https, e você pode ver que aqui está o nome do site ao qual estou me conectando, o nome do servidor ao qual estou me conectando e assim por diante, e assim por diante, no nível físico, o que está acontecendo aqui na rede é que temos todos esses pacotes de rede indo e voltando, e a razão pela qual temos muitos pacotes é que há um tamanho máximo para cada pacote, e você pode ver aqui nesta coluna, que tem o tamanho, o comprimento em bytes de cada pacote, e você pode ver que o comprimento só vai até cerca de 1500 bytes, aqui outro com 1500 bytes, mas não há nenhum maior do que isso, e isso ocorre porque as redes têm esse tamanho máximo de pacote, e se você quiser enviar uma mensagem maior do que o tamanho de um único pacote, você precisa dividi-la em vários pacotes, e é exatamente isso que o protocolo TCP faz, então o TCP HTTP é executado em cima do TCP, então o HTTP tem esse paradigma de mensagem de solicitação e resposta, mas uma solicitação pode ser maior do que uma pacote de rede único e uma resposta é provavelmente maior do que um único pacote de rede também, então o http usa o tcp por baixo e o tcp divide essas mensagens grandes em pequenos pacotes de rede que são pequenos o suficiente para que a rede possa entregá-los e, no lado do destinatário, o tcp reúne todos os pacotes de rede novamente para nos dar um grande pedaço de bytes e então isso é, uh, isso agora é algo importante a se ter em mente em sistemas distribuídos quando falamos sobre mensagens sendo enviadas e recebidas, não estamos falando de pacotes individuais porque uma mensagem pode ser maior do que um único pacote de rede e, portanto, essa mensagem precisa ser dividida em pequenos pacotes de rede, então a rede, a mensagem é realmente um objeto conceitual de nível mais alto que é enviado para frente e para trás entre dois nós e como exatamente isso é dividido no nível do pacote, isso é algo que deixamos para as pessoas de rede de computadores, então, do ponto de vista de sistemas distribuídos, podemos simplesmente assumir que temos esse mecanismo por meio do qual podemos enviar essas solicitações e essas respostas aqui e não nos importamos muito com os detalhes de como isso é realmente representado fisicamente em termos de pacotes de rede, simplesmente assumimos que temos esse mecanismo de comunicação.


Então, vimos a web como um exemplo de um sistema distribuído que consiste em um cliente e um servidor. Vamos dar uma olhada em outro exemplo prático: imagine que você está usando uma loja online para comprar algo. O que você quer fazer é inserir o número do seu cartão de crédito nessa loja depois de escolher o que deseja comprar. Depois de finalizar a compra, você paga com seu cartão de crédito e recebe os produtos enviados. O que acontece aqui é que o serviço de pagamento que realmente processa esse pagamento com cartão de crédito geralmente é fornecido por uma empresa diferente da empresa que administra a loja online, porque processar pagamentos com cartão de crédito é uma atividade muito especializada. Então, faz sentido que sejam empresas especializadas apenas em fazer pagamentos com cartão de crédito e outra empresa especializada em fornecer a loja e os produtos, e assim por diante. O que acontece quando você insere o número do seu cartão de crédito em uma loja online é que a loja online enviará uma mensagem para esse serviço de pagamento, que está sendo executado em um nó diferente, fornecido por uma empresa diferente. Essa mensagem conterá os detalhes do número do seu cartão, quanto eles querem cobrar desse cartão e várias outras informações, talvez seu endereço de cobrança, e assim por diante. Isso será enviado. para o serviço de pagamento, o serviço de pagamento então faz um monte de coisas complicadas, eles falam com a rede de pagamento com cartão, como reiniciar o Visa ou Mastercard, a rede de pagamento com cartão então fala com o banco que emitiu seu cartão, eles garantem que você realmente tem dinheiro em sua conta e então eles garantem que o pagamento pode ser feito e se for bem-sucedido, eles fazem tudo isso ao contrário e você sabe, talvez eles façam verificações extras para, uh, fazer você digitar uma senha ou enviar uma mensagem de texto ou o que quer que seja e, eventualmente, uh, esperançosamente, o serviço de pagamento então envia uma mensagem de volta para a loja online indicando se o pagamento foi bem-sucedido ou não e então este é um exemplo muito concreto de um sistema distribuído que é realmente usado assim todos os dias. Agora, vamos dar uma olhada um pouco em como o código pode ser, então imagine que você é um dos programadores trabalhando ao lado da loja online, então você está desenvolvendo o software que executa a loja online e você está escrevendo o código que deve lidar com os pagamentos com cartão de crédito e falar com o serviço de pagamento e então o código que você escreve pode ser algo como isto aqui, então vamos supor que Há um objeto de cartão em sua base de código e você pode criar uma nova instância desse objeto de cartão e pode dar a ele o número do cartão de crédito, a data de validade e os três dígitos no verso e pode empacotar tudo isso como um objeto de cartão e então você chama essa função para ter um objeto que tem esse serviço de pagamento e você chama o método de pagamento do processo nessa função e você dá a ele o cartão que você deseja cobrar e você dá a ele o valor que você deseja cobrar e a moeda na qual você deseja cobrar e então dependendo se isso for bem-sucedido ou não, você então atende ao pedido, então isso é bem interessante o que está acontecendo aqui porque se você pensar sobre isso, o serviço de pagamento está sendo executado em um modo diferente executado por uma empresa diferente, não faz parte da base de código da loja online, então o que está acontecendo aqui é quando você chama essa função de pagamento do processo, a implementação dessa função não está dentro do seu programa, a implementação está em algum lugar em outro nó na outra extremidade de uma conexão de internet e o que está realmente acontecendo aqui é o que parece ser uma função chamada chamada de método, na verdade está sendo traduzida em algum tipo de comunicação de rede e isso é chamado Uma chamada de procedimento remoto, talvez uma chamada de função remota seria um nome melhor, mas chamada de procedimento remoto é como essa coisa normalmente é chamada e, portanto, vamos continuar com esse nome. Java chama a mesma coisa, invocação de método remoto novamente, apenas uma palavra diferente para essencialmente a mesma ideia. Então, vamos dar uma olhada em como o RPC funciona. Uma chamada de procedimento remoto, então o RPC é normalmente implementado com algo chamado framework RPC ou é chamado de middleware. Às vezes, este é um software que executa a tradução entre a chamada de função em sua linguagem de programação e esta mensagem que passa pela rede. Então, quando o código da loja online chama essa função de pagamento de processo, ele não pode chamar a função diretamente em um nó diferente porque sua linguagem de programação não oferece suporte a isso. Normalmente, a estrutura RPC fornece o que é chamado de stub, então a função stub tem a mesma assinatura de tipo e se parece com a função no nó remoto que você deseja chamar. Então, você deseja chamar essa função de pagamento de processo e o que fazemos é essa função stub que, na verdade, não processa o pagamento, mas o que ela faz é enviar uma mensagem para o serviço que então processa o pagamento, então a loja online chama essa função stub aqui e o cliente RPC precisa pegar os argumentos que foram passados ​​para essa função e traduzi-los em uma mensagem que pode ser enviada pela rede e esse processo de tradução de argumentos em sua linguagem de programação para mensagem pela rede é chamado de marshalling e então o marshalling ou eu chamo de codificação também pega os argumentos da função e os codifica de alguma forma que possa ser enviada pela rede, então, por exemplo, pode usar JSON neste exemplo, ele usa JSON, pode usar algum tipo de formato binário, o formato realmente não importa, mas se torna essencialmente apenas uma sequência de bytes que podemos compactar em uma mensagem enviada pela rede e então, no lado do destinatário, o servidor RPC vai receber essa mensagem e vai traduzi-la de volta para uma chamada de função no lado do servidor e então aqui agora é onde a implementação real da função de pagamento do processo reside e então aqui no lado do servidor RPC agora esta função vai ser chamada e vai fazer o que for necessário para fazer esse pagamento acontecer e isso provavelmente envolverá falar com a rede do cartão e o banco e atualizando alguns bancos de dados e fazendo um monte de coisas extras e, eventualmente, esta função retornará e, com sorte, nos dirá se o pagamento com cartão foi bem-sucedido ou não, então o valor de retorno desta função precisa ser empacotado novamente. Fazemos exatamente o mesmo ao contrário, então o servidor RPC empacota o valor de retorno da função, envia-o de volta como uma mensagem m2 da rede, o cliente RPC o desempacota e o transforma de volta nos tipos de dados da linguagem de programação que você está usando e, eventualmente, a função retorna e então o que fizemos agora é fingir que isso que estamos fazendo é chamar uma função localmente, mas na verdade está acontecendo o que está acontecendo por baixo é esta comunicação, uh, via mensagens para outro serviço, então o ideal que queremos aqui é que a chamada de função local, uh, desculpe, a chamada de função para um serviço diferente se pareça com uma chamada de função local porque sabemos como são as funções em nossa linguagem de programação, gostaríamos que o RPC remoto se parecesse exatamente com isso e este princípio é chamado de transparência de localização, então a localização de onde seu recurso está localizado é se os objetos que você está chamando seu processo de pagamento, se é um objeto em seu próprio processo em seu espaço de endereço local ou se está em algum lugar na outra extremidade de uma conexão de internet, queremos que seja transparente, não queremos ser capazes de dizer a diferença entre os dois, no entanto, na verdade, a realidade não parece tão simples porque, como eu disse no início, o problema com as redes é que elas podem falhar, então pode ser que você envie uma mensagem pela rede e a mensagem não chegue, você pode enviá-la novamente, é claro, mas então você vai cobrar o cartão de crédito várias vezes, temos que ter muito cuidado se vamos enviar mensagens novamente, então as mensagens podem ser perdidas, o que fazemos com as novas tentativas? As mensagens também podem ser atrasadas, então pode ser que a mensagem realmente tenha chegado, mas por algum motivo houve alguns soluços de rede em algum lugar que causaram o atraso da mensagem por um tempo, o que também pode acontecer. Também pode acontecer que o serviço que está processando esta função travou no meio do manuseio, no meio da execução de nossa função, nesse caso, ele não será capaz de nos enviar uma resposta, mas pode ter processado parcialmente nossa solicitação, acho que podemos usar transações aqui, ácido, sim, ok, mas você pode ver que há muitas perguntas em aberto aqui e, fundamentalmente, parece que fazer uma chamada de função para um recurso remoto é algo totalmente diferente de chamar uma função local. São simplesmente duas coisas diferentes. Podemos fazer com que pareçam um pouco semelhantes. Podemos dar às funções uma assinatura de tipo semelhante, mas chamar uma função remota tem todos esses casos de erro que simplesmente não surgem na execução local. Mas isso não impediu as pessoas de tentar construir estruturas RPC por um longo tempo para tentar parecer que você está chamando uma função local, mesmo que esteja chamando algo em outro nó. Então, começou nos anos 80, quando o termo RPC foi cunhado pela primeira vez e, como alguns microssistemas, tinham essa coisa e era usada para construir NFS, o sistema de arquivos de rede do qual veremos mais tarde no curso. E então, na década de 1990, esse era um tópico muito quente. As pessoas falavam sobre middleware orientado a objetos e havia essa coisa chamada Corba, que era muito popular hoje em dia, ninguém mais usa. Então, havia um monte de tecnologias concorrentes como A invocação de método remoto do Java é um tipo semelhante ao Corba. Não entraremos em detalhes sobre todos eles. Estou apenas mencionando os nomes aqui porque você pode encontrá-los em sua carreira e, portanto, é bom pelo menos tê-los visto antes. E você sabe, recentemente, em 2015, o Google lançou outro framework RPC, chamado GRPC para o RPC do Google. E você sabe que é bom se você quiser fazer RPC, por que não? Você pode usá-lo? Você pode usar outra coisa. Não importa o que seja comum? Muito comum hoje em dia é algo chamado REST. Isso significa Transferência de Estado Representacional. É um pouco complicado, mas é realmente um conjunto de princípios sobre como usar HTTP. Pessoas que são entusiastas de REST não gostam de pensar em REST como RPC. Elas gostam de pensar em REST e RPC como duas filosofias diferentes, mas essencialmente são o mesmo tipo de coisa. Então, essencialmente, elas ainda são sobre invocar código e fazer com que algo aconteça em um serviço remoto, tornando algumas solicitações de rede para ele e empacotar tudo de uma forma razoavelmente boa em sua linguagem de programação, então um dos motivos pelos quais essa abordagem RESTful de construção de RPC se tornou tão popular foi que os navegadores da web suportam solicitações HTTP, então você pode ter algum código JavaScript em execução em um navegador da web e esse código pode fazer solicitações HTTP para um servidor e pode construir quaisquer dados que queira enviar nessa solicitação, enviar e receber a resposta de volta do servidor. Essa técnica às vezes também é chamada de AJAX e se parece com isso, então se eu quiser implementar este exemplo de pagamento com cartão de crédito em JavaScript, eu poderia primeiro criar este objeto arcs contendo os argumentos para a chamada de função para o RPC, de modo que conterá o valor, a moeda, o número do cartão, o endereço de cobrança e assim por diante, e então eu construo este objeto de solicitação que diz qual método HTTP eu quero usar, então post é o método usado para enviar formulários, geralmente quando você está alterando algum estado no servidor, agora vou pegar os argumentos e transformá-los em uma string JSON usando a função json.stringify e posso dizer ao servidor que JSON é o tipo de dados que estou fornecendo, então estou fornecendo o tipo de arquivo essencialmente e então posso chamar esta URL, o que significa, na verdade, enviar uma solicitação http para esta URL example.com pagamentos com todos os detalhes especificados acima e então temos esses dois manipuladores aqui embaixo, então o caso tem uma função de retorno aqui que é chamada se a solicitação de rede recebida resultou em uma resposta bem-sucedida, então se obtivermos uma resposta do servidor, então esta variável resposta aqui se torna essa resposta e então executamos este código aqui para que possamos agora olhar para a resposta que obtivemos do servidor e ver se o código de status que ele responde indica sucesso ou não, então se indicar sucesso, significa que a resposta provavelmente é json novamente, então podemos desempacotar isso de volta em objetos em JavaScript chamando esta função json e, em seguida, chamar a função de sucesso para indicar que obtivemos um status de sucesso do servidor, caso contrário, se o código de status não for sucesso, poderíamos chamar uma função de falha com o código de status, por exemplo, é claro que podemos fazer um tratamento de erro mais detalhado, mas essa é apenas a ideia geral, então este é o caso em que obtivemos uma resposta de volta de O servidor agora, é claro, as mensagens podem ser perdidas e, portanto, pode ser que não recebamos uma resposta do servidor e, neste caso, por exemplo, a solicitação pode apenas esperar 30 segundos e, se não receber nada em 30 segundos, dirá tempo limite, desistimos, a mensagem pode ter sido enviada ou não, não sabemos realmente, mas vamos dar a você um erro de rede e é isso que acontece aqui, então, neste caso de captura, temos outra função de retorno de chamada que é chamada se a solicitação de rede não resultou em uma resposta do servidor e, nesse caso, vou apenas chamar essa função de falha novamente e passar o erro. Na prática, você provavelmente gostaria de mostrar a mensagem do usuário e explicar que algo deu errado de qualquer maneira, então este é o básico de como você faria RPC, um e é assim que você usaria uma API REST sobre HTTP em JavaScript e esse padrão se tornou muito popular, como eu disse, para navegadores da web, e a maioria dos sites agora usará esse tipo de técnica para fazer solicitações HTTP para o servidor sem recarregar a página inteira e, portanto, é apenas JavaScript em execução. seu navegador da web que atua como um programa do lado do cliente que está executando essas solicitações de rede, mas técnicas muito semelhantes também são usadas para comunicação de servidor para servidor e, portanto, essa técnica é particularmente popular em grandes empresas. Em grandes empresas, você tem esses enormes sistemas de software que executam todas as operações da empresa e esses sistemas de software são muito grandes e complexos para ter apenas um único programa em execução em um computador, simplesmente por causa da grande complexidade, às vezes também por causa das grandes quantidades de dados que essas coisas precisam processar. Eles são sistemas distribuídos, então você tem vários nós em execução em vários computadores, todos fornecendo parte da infraestrutura dessa grande organização, pode ser um banco ou um varejista ou o que for, e esse grande conjunto de software é dividido no que chamamos de serviços e uma abordagem onde você divide um grande pedaço de software em serviços, chamada de arquitetura orientada a serviços ou, para algumas pessoas, um termo mais moderno é chamá-lo de microsserviços, e isso significa apenas ter programas em execução em diferentes nós que se comunicam via RPC, e o RPC é o mecanismo principal que permite que esses bits de software interajam. uns com os outros e então eu vou te contar um pouco mais sobre RPC nesse tipo de configuração, então nós vimos isso no navegador da web, mas aqui na arquitetura orientada a serviços você normalmente está falando sobre serviços que estão sendo executados dentro de um data center e então eles podem estar sendo executados em vários servidores diferentes no mesmo data center, mas geralmente são todos serviços se comunicando pela rede do data center, então esses não são serviços em execução no seu dispositivo de usuário final, como seu telefone ou seu laptop, mas são serviços do site do data center, mas podemos usar RPC igualmente bem, independentemente de serem dispositivos de usuário final se comunicando com um servidor ou servidores se comunicando com outros servidores. O que você obtém nesses sistemas corporativos de grande escala é que eles usam um monte de linguagens de programação diferentes porque eles têm alguns sistemas antigos, você sabe, eles podem ter alguns sistemas antigos escritos em COBOL, então eles terão alguns sistemas um pouco mais novos escritos em C Plus e têm sistemas um pouco mais novos escritos em Java e então eles terão os sistemas mais recentes em qualquer que seja a linguagem de programação mais moderna e moderna no momento, e esses sistemas precisam se comunicar entre si e, portanto, o RPC pode realmente fornecer um mecanismo para interoperabilidade entre Esses sistemas são escritos em diferentes linguagens de programação. Agora, isso significa que você sabe se o chamador da função e o código que está sendo chamado estão escritos em diferentes linguagens de programação. Agora, você precisa ter certeza de que as assinaturas de tipo corresponderão de alguma forma. Então, você precisa realizar alguma conversão de tipo de dados. Isso geralmente é implementado usando algo chamado linguagem de definição de interface ou IDL, que é essencialmente uma linguagem para especificar a assinatura de tipo ou chamadas de função de uma forma que não é específica para nenhuma linguagem de programação. Então, aqui está um exemplo de como é uma IDL. Este exemplo foi retirado do GRPC, o framework RPC do Google. Ele usa uma IDL chamada Protocol Buffers. Os detalhes não são importantes. Eu só quero dar uma ideia de como isso se parece. Então, o que você tem aqui é que você pode ter uma especificação de um tipo de mensagem, então podemos ter uma mensagem de solicitação de pagamento e uma mensagem de status de pagamento. Esses são dois tipos de mensagens diferentes. E aqui embaixo temos a especificação de um serviço. O serviço de pagamento tem uma RPC, oferece uma chamada de função RPC, que é chamada de processo de pagamento. Ela recebe como argumento uma solicitação de pagamento e retorna como valor de retorno o status do pagamento. Aqui em cima podemos dizer em que consiste uma solicitação de pagamento. Bem, uma solicitação de pagamento consiste em um cartão, um valor e uma moeda. E o cartão, por sua vez, consiste em um número de cartão, uma data de validade e os três dígitos no verso. A moeda pode ser uma enumeração que indica os valores possíveis. Ignore esses valores um, dois, três, quatro. Aqui, os detalhes disso não são importantes para os propósitos deste curso. Mas você pode ver aqui que estou usando tipos de dados como 32 para indicar que este é um inteiro assinado de 32 bits. E você pode ver que é como um tipo de dado bastante genérico que você esperaria que a maioria das linguagens de programação suportasse esse tipo de coisa. Da mesma forma, aqui, o tipo de dado string é muito comum, um enum. Você sabe, se a linguagem não suporta enums, você pode traduzi-lo apenas para um inteiro ou algo assim. O booleano, novamente, é um tipo de dado comum, então você pode argumentar que o número do cartão deve ser uma string ou um inteiro com dígitos suficientes para que você possa ter 16 dígitos. Podemos discutir sobre isso, mas você entende o princípio geral. Esta é uma especificação independente de linguagem de como o RPC pode se parecer e o O framework RPC pode pegar esse IDL, pegar uma especificação e gerar código em todas as suas linguagens de programação favoritas e, dessa forma, ele pode gerar os stubs para o cliente RPC e o servidor RPC, o que torna fácil escrever código que executa o RPC tanto no lado do chamador quanto no lado do serviço que está sendo chamado. Esse é o nosso PC. Na próxima vez, falaremos um pouco mais sobre as questões fundamentais para realmente criar sistemas distribuídos confiáveis.
